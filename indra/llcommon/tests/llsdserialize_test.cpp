/**
 * @file llsdserialize_test.cpp
 * @date 2006-04
 * @brief LLSDSerialize unit tests
 *
 * $LicenseInfo:firstyear=2006&license=viewerlgpl$
 * Second Life Viewer Source Code
 * Copyright (C) 2010, Linden Research, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation;
 * version 2.1 of the License only.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Linden Research, Inc., 945 Battery Street, San Francisco, CA  94111  USA
 * $/LicenseInfo$
 */


#include "linden_common.h"

#if LL_WINDOWS
#include <winsock2.h>
typedef U32 uint32_t;
#include <process.h>
#include <io.h>
#else
#include <unistd.h>
#include <netinet/in.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include "llprocess.h"
#include "llstring.h"
#endif

#include "boost/range.hpp"

#include "llsd.h"
#include "llsdserialize.h"
#include "llsdutil.h"
#include "llformat.h"
#include "llmemorystream.h"

#include "../test/hexdump.h"
#include "../test/lldoctest.h"
#include "../test/namedtempfile.h"
#include "stringize.h"
#include "StringVec.h"
#include <functional>

typedef std::function<void(const LLSD& data, std::ostream& str)> FormatterFunction;
typedef std::function<bool(std::istream& istr, LLSD& data, llssize max_bytes)> ParserFunction;

std::vector<U8> string_to_vector(const std::string& str)
{
    return std::vector<U8>(str.begin(), str.end());
}

TEST_SUITE("LLSDXMLFormatter") {

struct sd_xml_data
{

        sd_xml_data()
        {
            mFormatter = new LLSDXMLFormatter;
        
};

TEST_CASE_FIXTURE(sd_xml_data, "test_1")
{

        // random atomic tests
        std::string expected;

        expected = "<llsd><undef /></llsd>\n";
        xml_test("undef", expected);

        mSD = 3463;
        expected = "<llsd><integer>3463</integer></llsd>\n";
        xml_test("integer", expected);

        mSD = "";
        expected = "<llsd><string /></llsd>\n";
        xml_test("empty string", expected);

        mSD = "foobar";
        expected = "<llsd><string>foobar</string></llsd>\n";
        xml_test("string", expected);

        mSD = LLUUID::null;
        expected = "<llsd><uuid /></llsd>\n";
        xml_test("null uuid", expected);

        mSD = LLUUID("c96f9b1e-f589-4100-9774-d98643ce0bed");
        expected = "<llsd><uuid>c96f9b1e-f589-4100-9774-d98643ce0bed</uuid></llsd>\n";
        xml_test("uuid", expected);

        mSD = LLURI("https://secondlife.com/login");
        expected = "<llsd><uri>https://secondlife.com/login</uri></llsd>\n";
        xml_test("uri", expected);

        mSD = LLDate("2006-04-24T16:11:33Z");
        expected = "<llsd><date>2006-04-24T16:11:33Z</date></llsd>\n";
        xml_test("date", expected);

        // Generated by: echo -n 'hello' | openssl enc -e -base64
        std::vector<U8> hello;
        hello.push_back('h');
        hello.push_back('e');
        hello.push_back('l');
        hello.push_back('l');
        hello.push_back('o');
        mSD = hello;
        expected = "<llsd><binary encoding=\"base64\">aGVsbG8=</binary></llsd>\n";
        xml_test("binary", expected);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_2")
{

        // tests with boolean values.
        std::string expected;

        mFormatter->boolalpha(true);
        mSD = true;
        expected = "<llsd><boolean>true</boolean></llsd>\n";
        xml_test("bool alpha true", expected);
        mSD = false;
        expected = "<llsd><boolean>false</boolean></llsd>\n";
        xml_test("bool alpha false", expected);

        mFormatter->boolalpha(false);
        mSD = true;
        expected = "<llsd><boolean>1</boolean></llsd>\n";
        xml_test("bool true", expected);
        mSD = false;
        expected = "<llsd><boolean>0</boolean></llsd>\n";
        xml_test("bool false", expected);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_3")
{

        // tests with real values.
        std::string expected;

        mFormatter->realFormat("%.2f");
        mSD = 1.0;
        expected = "<llsd><real>1.00</real></llsd>\n";
        xml_test("real 1", expected);

        mSD = -34379.0438;
        expected = "<llsd><real>-34379.04</real></llsd>\n";
        xml_test("real reduced precision", expected);
        mFormatter->realFormat("%.4f");
        expected = "<llsd><real>-34379.0438</real></llsd>\n";
        xml_test("higher precision", expected);

        mFormatter->realFormat("%.0f");
        mSD = 0.0;
        expected = "<llsd><real>0</real></llsd>\n";
        xml_test("no decimal 0", expected);
        mSD = 3287.4387;
        expected = "<llsd><real>3287</real></llsd>\n";
        xml_test("no decimal real number", expected);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_4")
{

        // tests with arrays
        std::string expected;

        mSD = LLSD::emptyArray();
        expected = "<llsd><array /></llsd>\n";
        xml_test("empty array", expected);

        mSD.append(LLSD());
        expected = "<llsd><array><undef /></array></llsd>\n";
        xml_test("1 element array", expected);

        mSD.append(1);
        expected = "<llsd><array><undef /><integer>1</integer></array></llsd>\n";
        xml_test("2 element array", expected);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_5")
{

        // tests with arrays
        std::string expected;

        mSD = LLSD::emptyMap();
        expected = "<llsd><map /></llsd>\n";
        xml_test("empty map", expected);

        mSD["foo"] = "bar";
        expected = "<llsd><map><key>foo</key><string>bar</string></map></llsd>\n";
        xml_test("1 element map", expected);

        mSD["baz"] = LLSD();
        expected = "<llsd><map><key>baz</key><undef /><key>foo</key><string>bar</string></map></llsd>\n";
        xml_test("2 element map", expected);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_6")
{

        // tests with binary
        std::string expected;

        // Generated by: echo -n 'hello' | openssl enc -e -base64
        mSD = string_to_vector("hello");
        expected = "<llsd><binary encoding=\"base64\">aGVsbG8=</binary></llsd>\n";
        xml_test("binary", expected);

        mSD = string_to_vector("6|6|asdfhappybox|60e44ec5-305c-43c2-9a19-b4b89b1ae2a6|60e44ec5-305c-43c2-9a19-b4b89b1ae2a6|60e44ec5-305c-43c2-9a19-b4b89b1ae2a6|00000000-0000-0000-0000-000000000000|7fffffff|7fffffff|0|0|82000|450fe394-2904-c9ad-214c-a07eb7feec29|(No Description)|0|10|0");
        expected = "<llsd><binary encoding=\"base64\">Nnw2fGFzZGZoYXBweWJveHw2MGU0NGVjNS0zMDVjLTQzYzItOWExOS1iNGI4OWIxYWUyYTZ8NjBlNDRlYzUtMzA1Yy00M2MyLTlhMTktYjRiODliMWFlMmE2fDYwZTQ0ZWM1LTMwNWMtNDNjMi05YTE5LWI0Yjg5YjFhZTJhNnwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDB8N2ZmZmZmZmZ8N2ZmZmZmZmZ8MHwwfDgyMDAwfDQ1MGZlMzk0LTI5MDQtYzlhZC0yMTRjLWEwN2ViN2ZlZWMyOXwoTm8gRGVzY3JpcHRpb24pfDB8MTB8MA==</binary></llsd>\n";
        xml_test("binary", expected);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_1")
{

        setFormatterParser(new LLSDNotationFormatter(false, "", LLSDFormatter::OPTIONS_PRETTY_BINARY),
                           new LLSDNotationParser());
        doRoundTripTests("pretty binary notation serialization");
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_2")
{

        setFormatterParser(new LLSDNotationFormatter(false, "", LLSDFormatter::OPTIONS_NONE),
                           new LLSDNotationParser());
        doRoundTripTests("raw binary notation serialization");
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_3")
{

        setFormatterParser(new LLSDXMLFormatter(), new LLSDXMLParser());
        doRoundTripTests("xml serialization");
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_4")
{

        setFormatterParser(new LLSDBinaryFormatter(), new LLSDBinaryParser());
        doRoundTripTests("binary serialization");
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_5")
{

        mFormatter = [](const LLSD& sd, std::ostream& str)
        {
            LLSDSerialize::serialize(sd, str, LLSDSerialize::LLSD_BINARY);
        
}

TEST_CASE_FIXTURE(sd_xml_data, "test_6")
{

        mFormatter = [](const LLSD& sd, std::ostream& str)
        {
            LLSDSerialize::serialize(sd, str, LLSDSerialize::LLSD_XML);
        
}

TEST_CASE_FIXTURE(sd_xml_data, "test_7")
{

        mFormatter = [](const LLSD& sd, std::ostream& str)
        {
            LLSDSerialize::serialize(sd, str, LLSDSerialize::LLSD_NOTATION);
        
}

TEST_CASE_FIXTURE(sd_xml_data, "test_8")
{

        setFormatterParser(new LLSDNotationFormatter(false, "", LLSDFormatter::OPTIONS_NONE),
                           new LLSDNotationParser());
        setParser(LLSDSerialize::deserialize);
        // This is an interesting test because LLSDNotationFormatter does not
        // emit an llsd/notation header.
        doRoundTripTests("LLSDNotationFormatter -> deserialize");
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_9")
{

        setFormatterParser(new LLSDXMLFormatter(false, "", LLSDFormatter::OPTIONS_NONE),
                           new LLSDXMLParser());
        setParser(LLSDSerialize::deserialize);
        // This is an interesting test because LLSDXMLFormatter does not
        // emit an LLSD/XML header.
        doRoundTripTests("LLSDXMLFormatter -> deserialize");
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_10")
{

        setFormatterParser(new LLSDBinaryFormatter(false, "", LLSDFormatter::OPTIONS_NONE),
                           new LLSDBinaryParser());
        setParser(LLSDSerialize::deserialize);
        // This is an interesting test because LLSDBinaryFormatter does not
        // emit an LLSD/Binary header.
        doRoundTripTests("LLSDBinaryFormatter -> deserialize");
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_1")
{

        // test handling of xml not recognized as llsd results in an
        // LLSD Undefined
        ensureParse(
            "malformed xml",
            "<llsd><string>ha ha</string>",
            LLSD(),
            LLSDParser::PARSE_FAILURE);
        ensureParse(
            "not llsd",
            "<html><body><p>ha ha</p></body></html>",
            LLSD(),
            LLSDParser::PARSE_FAILURE);
        ensureParse(
            "value without llsd",
            "<string>ha ha</string>",
            LLSD(),
            LLSDParser::PARSE_FAILURE);
        ensureParse(
            "key without llsd",
            "<key>ha ha</key>",
            LLSD(),
            LLSDParser::PARSE_FAILURE);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_2")
{

        // test handling of unrecognized or unparseable llsd values
        LLSD v;
        v["amy"] = 23;
        v["bob"] = LLSD();
        v["cam"] = 1.23;

        ensureParse(
            "unknown data type",
            "<llsd><map>"
                "<key>amy</key><integer>23</integer>"
                "<key>bob</key><bigint>99999999999999999</bigint>"
                "<key>cam</key><real>1.23</real>"
            "</map></llsd>",
            v,
            static_cast<S32>(v.size()) + 1);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_3")
{

        // test handling of nested bad data

        LLSD v;
        v["amy"] = 23;
        v["cam"] = 1.23;

        ensureParse(
            "map with html",
            "<llsd><map>"
                "<key>amy</key><integer>23</integer>"
                "<html><body>ha ha</body></html>"
                "<key>cam</key><real>1.23</real>"
            "</map></llsd>",
            v,
            static_cast<S32>(v.size()) + 1);

        v.clear();
        v["amy"] = 23;
        v["cam"] = 1.23;
        ensureParse(
            "map with value for key",
            "<llsd><map>"
                "<key>amy</key><integer>23</integer>"
                "<string>ha ha</string>"
                "<key>cam</key><real>1.23</real>"
            "</map></llsd>",
            v,
            static_cast<S32>(v.size()) + 1);

        v.clear();
        v["amy"] = 23;
        v["bob"] = LLSD::emptyMap();
        v["cam"] = 1.23;
        ensureParse(
            "map with map of html",
            "<llsd><map>"
                "<key>amy</key><integer>23</integer>"
                "<key>bob</key>"
                "<map>"
                    "<html><body>ha ha</body></html>"
                "</map>"
                "<key>cam</key><real>1.23</real>"
            "</map></llsd>",
            v,
            static_cast<S32>(v.size()) + 1);

        v.clear();
        v[0] = 23;
        v[1] = LLSD();
        v[2] = 1.23;

        ensureParse(
            "array value of html",
            "<llsd><array>"
                "<integer>23</integer>"
                "<html><body>ha ha</body></html>"
                "<real>1.23</real>"
            "</array></llsd>",
            v,
            static_cast<S32>(v.size()) + 1);

        v.clear();
        v[0] = 23;
        v[1] = LLSD::emptyMap();
        v[2] = 1.23;
        ensureParse(
            "array with map of html",
            "<llsd><array>"
                "<integer>23</integer>"
                "<map>"
                    "<html><body>ha ha</body></html>"
                "</map>"
                "<real>1.23</real>"
            "</array></llsd>",
            v,
            static_cast<S32>(v.size()) + 1);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_4")
{

        // test handling of binary object in XML
        std::string xml;
        LLSD expected;

        // Generated by: echo -n 'hello' | openssl enc -e -base64
        expected = string_to_vector("hello");
        xml = "<llsd><binary encoding=\"base64\">aGVsbG8=</binary></llsd>\n";
        ensureParse(
            "the word 'hello' packed in binary encoded base64",
            xml,
            expected,
            1);

        expected = string_to_vector("6|6|asdfhappybox|60e44ec5-305c-43c2-9a19-b4b89b1ae2a6|60e44ec5-305c-43c2-9a19-b4b89b1ae2a6|60e44ec5-305c-43c2-9a19-b4b89b1ae2a6|00000000-0000-0000-0000-000000000000|7fffffff|7fffffff|0|0|82000|450fe394-2904-c9ad-214c-a07eb7feec29|(No Description)|0|10|0");
        xml = "<llsd><binary encoding=\"base64\">Nnw2fGFzZGZoYXBweWJveHw2MGU0NGVjNS0zMDVjLTQzYzItOWExOS1iNGI4OWIxYWUyYTZ8NjBlNDRlYzUtMzA1Yy00M2MyLTlhMTktYjRiODliMWFlMmE2fDYwZTQ0ZWM1LTMwNWMtNDNjMi05YTE5LWI0Yjg5YjFhZTJhNnwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDB8N2ZmZmZmZmZ8N2ZmZmZmZmZ8MHwwfDgyMDAwfDQ1MGZlMzk0LTI5MDQtYzlhZC0yMTRjLWEwN2ViN2ZlZWMyOXwoTm8gRGVzY3JpcHRpb24pfDB8MTB8MA==</binary></llsd>\n";
        ensureParse(
            "a common binary blob for object -> agent offline inv transfer",
            xml,
            expected,
            1);

        expected = string_to_vector("6|6|asdfhappybox|60e44ec5-305c-43c2-9a19-b4b89b1ae2a6|60e44ec5-305c-43c2-9a19-b4b89b1ae2a6|60e44ec5-305c-43c2-9a19-b4b89b1ae2a6|00000000-0000-0000-0000-000000000000|7fffffff|7fffffff|0|0|82000|450fe394-2904-c9ad-214c-a07eb7feec29|(No Description)|0|10|0");
        xml = "<llsd><binary encoding=\"base64\">Nnw2fGFzZGZoYXBweWJveHw2MGU0NGVjNS0zMDVjLTQzYzItOWExOS1iNGI4OWIxYWUyYTZ8NjBl\n";
        xml += "NDRlYzUtMzA1Yy00M2MyLTlhMTktYjRiODliMWFlMmE2fDYwZTQ0ZWM1LTMwNWMtNDNjMi05YTE5\n";
        xml += "LWI0Yjg5YjFhZTJhNnwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDB8N2ZmZmZm\n";
        xml += "ZmZ8N2ZmZmZmZmZ8MHwwfDgyMDAwfDQ1MGZlMzk0LTI5MDQtYzlhZC0yMTRjLWEwN2ViN2ZlZWMy\n";
        xml += "OXwoTm8gRGVzY3JpcHRpb24pfDB8MTB8MA==</binary></llsd>\n";
        ensureParse(
            "a common binary blob for object -> agent offline inv transfer",
            xml,
            expected,
            1);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_5")
{

        // test deeper nested levels
        LLSD level_5 = LLSD::emptyMap();      level_5["level_5"] = 42.f;
        LLSD level_4 = LLSD::emptyMap();      level_4["level_4"] = level_5;
        LLSD level_3 = LLSD::emptyMap();      level_3["level_3"] = level_4;
        LLSD level_2 = LLSD::emptyMap();      level_2["level_2"] = level_3;
        LLSD level_1 = LLSD::emptyMap();      level_1["level_1"] = level_2;
        LLSD level_0 = LLSD::emptyMap();      level_0["level_0"] = level_1;

        LLSD v;
        v["deep"] = level_0;

        ensureParse(
            "deep llsd xml map",
            "<llsd><map>"
            "<key>deep</key><map>"
            "<key>level_0</key><map>"
            "<key>level_1</key><map>"
            "<key>level_2</key><map>"
            "<key>level_3</key><map>"
            "<key>level_4</key><map>"
            "<key>level_5</key><real>42.0</real>"
            "</map>"
            "</map>"
            "</map>"
            "</map>"
            "</map>"
            "</map>"
            "</map></llsd>",
            v,
            8);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_1")
{

        // test handling of xml not recognized as llsd results in an
        // LLSD Undefined
        ensureParse(
            "malformed notation map",
            "{'ha ha'",
            LLSD(),
            LLSDParser::PARSE_FAILURE);
        ensureParse(
            "malformed notation array",
            "['ha ha'",
            LLSD(),
            LLSDParser::PARSE_FAILURE);
        ensureParse(
            "malformed notation string",
            "'ha ha",
            LLSD(),
            LLSDParser::PARSE_FAILURE);
        ensureParse(
            "bad notation noise",
            "g48ejlnfr",
            LLSD(),
            LLSDParser::PARSE_FAILURE);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_2")
{

        ensureParse("valid undef", "!", LLSD(), 1);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_3")
{

        LLSD val = false;
        ensureParse("valid boolean false 0", "false", val, 1);
        ensureParse("valid boolean false 1", "f", val, 1);
        ensureParse("valid boolean false 2", "0", val, 1);
        ensureParse("valid boolean false 3", "F", val, 1);
        ensureParse("valid boolean false 4", "FALSE", val, 1);
        val = true;
        ensureParse("valid boolean true 0", "true", val, 1);
        ensureParse("valid boolean true 1", "t", val, 1);
        ensureParse("valid boolean true 2", "1", val, 1);
        ensureParse("valid boolean true 3", "T", val, 1);
        ensureParse("valid boolean true 4", "TRUE", val, 1);

        val.clear();
        ensureParse("invalid true", "TR", val, LLSDParser::PARSE_FAILURE);
        ensureParse("invalid false", "FAL", val, LLSDParser::PARSE_FAILURE);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_4")
{

        LLSD val = 123;
        ensureParse("valid integer", "i123", val, 1);
        val.clear();
        ensureParse("invalid integer", "421", val, LLSDParser::PARSE_FAILURE);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_5")
{

        LLSD val = 456.7;
        ensureParse("valid real", "r456.7", val, 1);
        val.clear();
        ensureParse("invalid real", "456.7", val, LLSDParser::PARSE_FAILURE);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_6")
{

        LLUUID id;
        LLSD val = id;
        ensureParse(
            "unparseable uuid",
            "u123",
            LLSD(),
            LLSDParser::PARSE_FAILURE);
        id.generate();
        val = id;
        std::string uuid_str("u");
        uuid_str += id.asString();
        ensureParse("valid uuid", uuid_str.c_str(), val, 1);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_7")
{

        LLSD val = std::string("foolish");
        ensureParse("valid string 1", "\"foolish\"", val, 1);
        val = std::string("g'day");
        ensureParse("valid string 2", "\"g'day\"", val, 1);
        val = std::string("have a \"nice\" day");
        ensureParse("valid string 3", "'have a \"nice\" day'", val, 1);
        val = std::string("whatever");
        ensureParse("valid string 4", "s(8)\"whatever\"", val, 1);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_8")
{

        ensureParse(
            "invalid string 1",
            "s(7)\"whatever\"",
            LLSD(),
            LLSDParser::PARSE_FAILURE);
        ensureParse(
            "invalid string 2",
            "s(9)\"whatever\"",
            LLSD(),
            LLSDParser::PARSE_FAILURE);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_9")
{

        LLSD val = LLURI("http://www.google.com");
        ensureParse("valid uri", "l\"http://www.google.com\"", val, 1);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_10")
{

        LLSD val = LLDate("2007-12-28T09:22:53.10Z");
        ensureParse("valid date", "d\"2007-12-28T09:22:53.10Z\"", val, 1);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_11")
{

        std::vector<U8> vec;
        vec.push_back((U8)'a'); vec.push_back((U8)'b'); vec.push_back((U8)'c');
        vec.push_back((U8)'3'); vec.push_back((U8)'2'); vec.push_back((U8)'1');
        LLSD val = vec;
        ensureParse("valid binary b64", "b64\"YWJjMzIx\"", val, 1);
        ensureParse("valid bainry b16", "b16\"616263333231\"", val, 1);
        ensureParse("valid bainry raw", "b(6)\"abc321\"", val, 1);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_12")
{

        ensureParse(
            "invalid -- binary length specified too long",
            "b(7)\"abc321\"",
            LLSD(),
            LLSDParser::PARSE_FAILURE);
        ensureParse(
            "invalid -- binary length specified way too long",
            "b(1000000)\"abc321\"",
            LLSD(),
            LLSDParser::PARSE_FAILURE);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_13")
{

        LLSD val;
        val["amy"] = 23;
        val["bob"] = LLSD();
        val["cam"] = 1.23;
        ensureParse("simple map", "{'amy':i23,'bob':!,'cam':r1.23
}

TEST_CASE_FIXTURE(sd_xml_data, "test_14")
{

        LLSD val;
        val.append(23);
        val.append(LLSD());
        val.append(1.23);
        ensureParse("simple array", "[i23,!,r1.23]", val, 4);
        val[1] = LLSD::emptyArray();
        val[1].append("bicycle");
        ensureParse("nested array", "[i23,['bicycle'],r1.23]", val, 5);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_15")
{

        LLSD val;
        val["amy"] = 23;
        val["bob"]["dogs"] = LLSD::emptyArray();
        val["bob"]["dogs"].append(LLSD::emptyMap());
        val["bob"]["dogs"][0]["name"] = std::string("groove");
        val["bob"]["dogs"][0]["breed"] = std::string("samoyed");
        val["bob"]["dogs"].append(LLSD::emptyMap());
        val["bob"]["dogs"][1]["name"] = std::string("greyley");
        val["bob"]["dogs"][1]["breed"] = std::string("chow/husky");
        val["cam"] = 1.23;
        ensureParse(
            "nested notation",
            "{'amy':i23,"
            " 'bob':{'dogs':["
                     "{'name':'groove', 'breed':'samoyed'
}

TEST_CASE_FIXTURE(sd_xml_data, "test_16")
{

        // text to make sure that incorrect sizes bail because
        std::string bad_str("s(5)\"hi\"");
        ensureParse(
            "size longer than bytes left",
            bad_str,
            LLSD(),
            LLSDParser::PARSE_FAILURE);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_17")
{

        // text to make sure that incorrect sizes bail because
        std::string bad_bin("b(5)\"hi\"");
        ensureParse(
            "size longer than bytes left",
            bad_bin,
            LLSD(),
            LLSDParser::PARSE_FAILURE);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_18")
{

        LLSD level_1 = LLSD::emptyMap();        level_1["level_2"] = 99;
        LLSD level_0 = LLSD::emptyMap();        level_0["level_1"] = level_1;

        LLSD deep = LLSD::emptyMap();
        deep["level_0"] = level_0;

        LLSD root = LLSD::emptyMap();
        root["deep"] = deep;

        ensureParse(
            "nested notation 3 deep",
            "{'deep' : {'level_0':{'level_1':{'level_2': i99
}

TEST_CASE_FIXTURE(sd_xml_data, "test_19")
{

        LLSD level_9 = LLSD::emptyMap();      level_9["level_9"] = (S32)99;
        LLSD level_8 = LLSD::emptyMap();      level_8["level_8"] = level_9;
        LLSD level_7 = LLSD::emptyMap();      level_7["level_7"] = level_8;
        LLSD level_6 = LLSD::emptyMap();      level_6["level_6"] = level_7;
        LLSD level_5 = LLSD::emptyMap();      level_5["level_5"] = level_6;
        LLSD level_4 = LLSD::emptyMap();      level_4["level_4"] = level_5;
        LLSD level_3 = LLSD::emptyMap();      level_3["level_3"] = level_4;
        LLSD level_2 = LLSD::emptyMap();      level_2["level_2"] = level_3;
        LLSD level_1 = LLSD::emptyMap();      level_1["level_1"] = level_2;
        LLSD level_0 = LLSD::emptyMap();      level_0["level_0"] = level_1;

        LLSD deep = LLSD::emptyMap();
        deep["deep"] = level_0;

        ensureParse(
            "nested notation 10 deep",
            "{'deep' : {'level_0':{'level_1':{'level_2':{'level_3':{'level_4':{'level_5':{'level_6':{'level_7':{'level_8':{'level_9':i99
}

TEST_CASE_FIXTURE(sd_xml_data, "test_20")
{

        LLSD end = LLSD::emptyMap();          end["end"] = (S32)99;

        LLSD level_49 = LLSD::emptyMap();     level_49["level_49"] = end;
        LLSD level_48 = LLSD::emptyMap();     level_48["level_48"] = level_49;
        LLSD level_47 = LLSD::emptyMap();     level_47["level_47"] = level_48;
        LLSD level_46 = LLSD::emptyMap();     level_46["level_46"] = level_47;
        LLSD level_45 = LLSD::emptyMap();     level_45["level_45"] = level_46;
        LLSD level_44 = LLSD::emptyMap();     level_44["level_44"] = level_45;
        LLSD level_43 = LLSD::emptyMap();     level_43["level_43"] = level_44;
        LLSD level_42 = LLSD::emptyMap();     level_42["level_42"] = level_43;
        LLSD level_41 = LLSD::emptyMap();     level_41["level_41"] = level_42;
        LLSD level_40 = LLSD::emptyMap();     level_40["level_40"] = level_41;

        LLSD level_39 = LLSD::emptyMap();     level_39["level_39"] = level_40;
        LLSD level_38 = LLSD::emptyMap();     level_38["level_38"] = level_39;
        LLSD level_37 = LLSD::emptyMap();     level_37["level_37"] = level_38;
        LLSD level_36 = LLSD::emptyMap();     level_36["level_36"] = level_37;
        LLSD level_35 = LLSD::emptyMap();     level_35["level_35"] = level_36;
        LLSD level_34 = LLSD::emptyMap();     level_34["level_34"] = level_35;
        LLSD level_33 = LLSD::emptyMap();     level_33["level_33"] = level_34;
        LLSD level_32 = LLSD::emptyMap();     level_32["level_32"] = level_33;
        LLSD level_31 = LLSD::emptyMap();     level_31["level_31"] = level_32;
        LLSD level_30 = LLSD::emptyMap();     level_30["level_30"] = level_31;

        LLSD level_29 = LLSD::emptyMap();     level_29["level_29"] = level_30;
        LLSD level_28 = LLSD::emptyMap();     level_28["level_28"] = level_29;
        LLSD level_27 = LLSD::emptyMap();     level_27["level_27"] = level_28;
        LLSD level_26 = LLSD::emptyMap();     level_26["level_26"] = level_27;
        LLSD level_25 = LLSD::emptyMap();     level_25["level_25"] = level_26;
        LLSD level_24 = LLSD::emptyMap();     level_24["level_24"] = level_25;
        LLSD level_23 = LLSD::emptyMap();     level_23["level_23"] = level_24;
        LLSD level_22 = LLSD::emptyMap();     level_22["level_22"] = level_23;
        LLSD level_21 = LLSD::emptyMap();     level_21["level_21"] = level_22;
        LLSD level_20 = LLSD::emptyMap();     level_20["level_20"] = level_21;

        LLSD level_19 = LLSD::emptyMap();     level_19["level_19"] = level_20;
        LLSD level_18 = LLSD::emptyMap();     level_18["level_18"] = level_19;
        LLSD level_17 = LLSD::emptyMap();     level_17["level_17"] = level_18;
        LLSD level_16 = LLSD::emptyMap();     level_16["level_16"] = level_17;
        LLSD level_15 = LLSD::emptyMap();     level_15["level_15"] = level_16;
        LLSD level_14 = LLSD::emptyMap();     level_14["level_14"] = level_15;
        LLSD level_13 = LLSD::emptyMap();     level_13["level_13"] = level_14;
        LLSD level_12 = LLSD::emptyMap();     level_12["level_12"] = level_13;
        LLSD level_11 = LLSD::emptyMap();     level_11["level_11"] = level_12;
        LLSD level_10 = LLSD::emptyMap();     level_10["level_10"] = level_11;

        LLSD level_9 = LLSD::emptyMap();      level_9["level_9"] = level_10;
        LLSD level_8 = LLSD::emptyMap();      level_8["level_8"] = level_9;
        LLSD level_7 = LLSD::emptyMap();      level_7["level_7"] = level_8;
        LLSD level_6 = LLSD::emptyMap();      level_6["level_6"] = level_7;
        LLSD level_5 = LLSD::emptyMap();      level_5["level_5"] = level_6;
        LLSD level_4 = LLSD::emptyMap();      level_4["level_4"] = level_5;
        LLSD level_3 = LLSD::emptyMap();      level_3["level_3"] = level_4;
        LLSD level_2 = LLSD::emptyMap();      level_2["level_2"] = level_3;
        LLSD level_1 = LLSD::emptyMap();      level_1["level_1"] = level_2;
        LLSD level_0 = LLSD::emptyMap();      level_0["level_0"] = level_1;

        LLSD deep = LLSD::emptyMap();
        deep["deep"] = level_0;

        ensureParse(
            "nested notation deep",
            "{'deep':"
            "{'level_0' :{'level_1' :{'level_2' :{'level_3' :{'level_4' :{'level_5' :{'level_6' :{'level_7' :{'level_8' :{'level_9' :"
            "{'level_10':{'level_11':{'level_12':{'level_13':{'level_14':{'level_15':{'level_16':{'level_17':{'level_18':{'level_19':"
            "{'level_20':{'level_21':{'level_22':{'level_23':{'level_24':{'level_25':{'level_26':{'level_27':{'level_28':{'level_29':"
            "{'level_30':{'level_31':{'level_32':{'level_33':{'level_34':{'level_35':{'level_36':{'level_37':{'level_38':{'level_39':"
            "{'level_40':{'level_41':{'level_42':{'level_43':{'level_44':{'level_45':{'level_46':{'level_47':{'level_48':{'level_49':"
            "{'end':i99
}

TEST_CASE_FIXTURE(sd_xml_data, "test_21")
{

        ensureParse(
            "nested notation 10 deep",
            "{'deep' : {'level_0':{'level_1':{'level_2':{'level_3':{'level_4':{'level_5':{'level_6':{'level_7':{'level_8':{'level_9':i99
}

TEST_CASE_FIXTURE(sd_xml_data, "test_1")
{

        std::vector<U8> vec;
        vec.resize(6);
        vec[0] = 'a'; vec[1] = 'b'; vec[2] = 'c';
        vec[3] = '3'; vec[4] = '2'; vec[5] = '1';
        std::string string_expected((char*)&vec[0], vec.size());
        LLSD value = string_expected;

        vec.resize(11);
        vec[0] = 's'; // for string
        vec[5] = 'a'; vec[6] = 'b'; vec[7] = 'c';
        vec[8] = '3'; vec[9] = '2'; vec[10] = '1';

        uint32_t size = htonl(6);
        memcpy(&vec[1], &size, sizeof(uint32_t));
        std::string str_good((char*)&vec[0], vec.size());
        ensureParse("correct string parse", str_good, value, 1);

        size = htonl(7);
        memcpy(&vec[1], &size, sizeof(uint32_t));
        std::string str_bad_1((char*)&vec[0], vec.size());
        ensureParse(
            "incorrect size string parse",
            str_bad_1,
            LLSD(),
            LLSDParser::PARSE_FAILURE);

        size = htonl(100000);
        memcpy(&vec[1], &size, sizeof(uint32_t));
        std::string str_bad_2((char*)&vec[0], vec.size());
        ensureParse(
            "incorrect size string parse",
            str_bad_2,
            LLSD(),
            LLSDParser::PARSE_FAILURE);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_2")
{

        std::vector<U8> vec;
        vec.resize(6);
        vec[0] = 'a'; vec[1] = 'b'; vec[2] = 'c';
        vec[3] = '3'; vec[4] = '2'; vec[5] = '1';
        LLSD value = vec;

        vec.resize(11);
        vec[0] = 'b';  // for binary
        vec[5] = 'a'; vec[6] = 'b'; vec[7] = 'c';
        vec[8] = '3'; vec[9] = '2'; vec[10] = '1';

        uint32_t size = htonl(6);
        memcpy(&vec[1], &size, sizeof(uint32_t));
        std::string str_good((char*)&vec[0], vec.size());
        ensureParse("correct binary parse", str_good, value, 1);

        size = htonl(7);
        memcpy(&vec[1], &size, sizeof(uint32_t));
        std::string str_bad_1((char*)&vec[0], vec.size());
        ensureParse(
            "incorrect size binary parse 1",
            str_bad_1,
            LLSD(),
            LLSDParser::PARSE_FAILURE);

        size = htonl(100000);
        memcpy(&vec[1], &size, sizeof(uint32_t));
        std::string str_bad_2((char*)&vec[0], vec.size());
        ensureParse(
            "incorrect size binary parse 2",
            str_bad_2,
            LLSD(),
            LLSDParser::PARSE_FAILURE);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_3")
{

        // test handling of xml not recognized as llsd results in an
        // LLSD Undefined
        ensureParse(
            "malformed binary map",
            "{'ha ha'",
            LLSD(),
            LLSDParser::PARSE_FAILURE);
        ensureParse(
            "malformed binary array",
            "['ha ha'",
            LLSD(),
            LLSDParser::PARSE_FAILURE);
        ensureParse(
            "malformed binary string",
            "'ha ha",
            LLSD(),
            LLSDParser::PARSE_FAILURE);
        ensureParse(
            "bad noise",
            "g48ejlnfr",
            LLSD(),
            LLSDParser::PARSE_FAILURE);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_4")
{

        ensureParse("valid undef", "!", LLSD(), 1);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_5")
{

        LLSD val = false;
        ensureParse("valid boolean false 2", "0", val, 1);
        val = true;
        ensureParse("valid boolean true 2", "1", val, 1);

        val.clear();
        ensureParse("invalid true", "t", val, LLSDParser::PARSE_FAILURE);
        ensureParse("invalid false", "f", val, LLSDParser::PARSE_FAILURE);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_6")
{

        std::vector<U8> vec;
        vec.push_back('{');
        vec.resize(vec.size() + 4);
        uint32_t size = htonl(1);
        memcpy(&vec[1], &size, sizeof(uint32_t));
        vec.push_back('k');
        auto key_size_loc = vec.size();
        size = htonl(1); // 1 too short
        vec.resize(vec.size() + 4);
        memcpy(&vec[key_size_loc], &size, sizeof(uint32_t));
        vec.push_back('a'); vec.push_back('m'); vec.push_back('y');
        vec.push_back('i');
        auto integer_loc = vec.size();
        vec.resize(vec.size() + 4);
        uint32_t val_int = htonl(23);
        memcpy(&vec[integer_loc], &val_int, sizeof(uint32_t));
        std::string str_bad_1((char*)&vec[0], vec.size());
        ensureParse(
            "invalid key size",
            str_bad_1,
            LLSD(),
            LLSDParser::PARSE_FAILURE);

        // check with correct size, but unterminated map (missing '
}

TEST_CASE_FIXTURE(sd_xml_data, "test_7")
{

        std::vector<U8> vec;
        vec.push_back('[');
        vec.resize(vec.size() + 4);
        uint32_t size = htonl(1); // 1 too short
        memcpy(&vec[1], &size, sizeof(uint32_t));
        vec.push_back('"'); vec.push_back('a'); vec.push_back('m');
        vec.push_back('y'); vec.push_back('"'); vec.push_back('i');
        auto integer_loc = vec.size();
        vec.resize(vec.size() + 4);
        uint32_t val_int = htonl(23);
        memcpy(&vec[integer_loc], &val_int, sizeof(uint32_t));

        std::string str_bad_1((char*)&vec[0], vec.size());
        ensureParse(
            "invalid array size",
            str_bad_1,
            LLSD(),
            LLSDParser::PARSE_FAILURE);

        // check with correct size, but unterminated map (missing ']')
        size = htonl(2); // correct size
        memcpy(&vec[1], &size, sizeof(uint32_t));
        std::string str_bad_2((char*)&vec[0], vec.size());
        ensureParse(
            "unterminated array",
            str_bad_2,
            LLSD(),
            LLSDParser::PARSE_FAILURE);

        // check w/ correct size and correct map termination
        LLSD val;
        val.append("amy");
        val.append(23);
        vec.push_back(']');
        std::string str_good((char*)&vec[0], vec.size());
        ensureParse(
            "valid array",
            str_good,
            val,
            3);

        // check with too many elements
        size = htonl(3); // 1 too long
        memcpy(&vec[1], &size, sizeof(uint32_t));
        std::string str_bad_3((char*)&vec[0], vec.size());
        ensureParse(
            "array too short",
            str_bad_3,
            LLSD(),
            LLSDParser::PARSE_FAILURE);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_8")
{

        std::vector<U8> vec;
        vec.push_back('{');
        vec.resize(vec.size() + 4);
        memset(&vec[1], 0, 4);
        vec.push_back('
}

TEST_CASE_FIXTURE(sd_xml_data, "test_9")
{

        std::vector<U8> vec;
        vec.push_back('[');
        vec.resize(vec.size() + 4);
        memset(&vec[1], 0, 4);
        vec.push_back(']');
        std::string str_good((char*)&vec[0], vec.size());
        LLSD val = LLSD::emptyArray();
        ensureParse(
            "empty array",
            str_good,
            val,
            1);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_10")
{

        std::vector<U8> vec;
        vec.push_back('l');
        vec.resize(vec.size() + 4);
        uint32_t size = htonl(14); // 1 too long
        memcpy(&vec[1], &size, sizeof(uint32_t));
        vec.push_back('h'); vec.push_back('t'); vec.push_back('t');
        vec.push_back('p'); vec.push_back(':'); vec.push_back('/');
        vec.push_back('/'); vec.push_back('s'); vec.push_back('l');
        vec.push_back('.'); vec.push_back('c'); vec.push_back('o');
        vec.push_back('m');
        std::string str_bad((char*)&vec[0], vec.size());
        ensureParse(
            "invalid uri length size",
            str_bad,
            LLSD(),
            LLSDParser::PARSE_FAILURE);

        LLSD val;
        val = LLURI("http://sl.com");
        size = htonl(13); // correct length
        memcpy(&vec[1], &size, sizeof(uint32_t));
        std::string str_good((char*)&vec[0], vec.size());
        ensureParse(
            "valid key size",
            str_good,
            val,
            1);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_11")
{

    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_1")
{

        LLSD test;
        ensureBinaryAndNotation("undef", test);
        ensureBinaryAndXML("undef", test);
        test = true;
        ensureBinaryAndNotation("boolean true", test);
        ensureBinaryAndXML("boolean true", test);
        test = false;
        ensureBinaryAndNotation("boolean false", test);
        ensureBinaryAndXML("boolean false", test);
        test = 0;
        ensureBinaryAndNotation("integer zero", test);
        ensureBinaryAndXML("integer zero", test);
        test = 1;
        ensureBinaryAndNotation("integer positive", test);
        ensureBinaryAndXML("integer positive", test);
        test = -234567;
        ensureBinaryAndNotation("integer negative", test);
        ensureBinaryAndXML("integer negative", test);
        test = 0.0;
        ensureBinaryAndNotation("real zero", test);
        ensureBinaryAndXML("real zero", test);
        test = 1.0;
        ensureBinaryAndNotation("real positive", test);
        ensureBinaryAndXML("real positive", test);
        test = -1.0;
        ensureBinaryAndNotation("real negative", test);
        ensureBinaryAndXML("real negative", test);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_2")
{

        LLSD test;
        test = "foobar";
        ensureBinaryAndNotation("string", test);
        ensureBinaryAndXML("string", test);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_3")
{

        LLSD test;
        LLUUID id;
        id.generate();
        test = id;
        ensureBinaryAndNotation("uuid", test);
        ensureBinaryAndXML("uuid", test);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_4")
{

        LLSD test;
        test = LLDate(12345.0);
        ensureBinaryAndNotation("date", test);
        ensureBinaryAndXML("date", test);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_5")
{

        LLSD test;
        test = LLURI("http://www.secondlife.com/");
        ensureBinaryAndNotation("uri", test);
        ensureBinaryAndXML("uri", test);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_6")
{

        LLSD test;
        typedef std::vector<U8> buf_t;
        buf_t val;
        for(int ii = 0; ii < 100; ++ii)
        {
            srand(ii);      /* Flawfinder: ignore */
            S32 size = rand() % 100 + 10;
            std::generate_n(
                std::back_insert_iterator<buf_t>(val),
                size,
                rand);
        
}

TEST_CASE_FIXTURE(sd_xml_data, "test_7")
{

        LLSD test;
        test = LLSD::emptyArray();
        test.append(1);
        test.append("hello");
        ensureBinaryAndNotation("array", test);
        ensureBinaryAndXML("array", test);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_8")
{

        LLSD test;
        test = LLSD::emptyArray();
        test["foo"] = "bar";
        test["baz"] = 100;
        ensureBinaryAndNotation("map", test);
        ensureBinaryAndXML("map", test);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_1")
{

        set_test_name("verify python()");
        python_expect("hello",
                      "import sys\n"
                      "sys.exit(17)\n",
                      17);                 // expect nonzero rc
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_2")
{

        set_test_name("verify NamedTempFile");
        python("platform",
               "import sys\n"
               "print('Running on', sys.platform)\n");
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_3")
{

        set_test_name("to Python using LLSDSerialize::serialize(LLSD_XML)");
        toPythonUsing("LLSD_XML",
                      [](const LLSD& sd, std::ostream& out)
        { LLSDSerialize::serialize(sd, out, LLSDSerialize::LLSD_XML); 
}

TEST_CASE_FIXTURE(sd_xml_data, "test_4")
{

        set_test_name("to Python using LLSDSerialize::serialize(LLSD_NOTATION)");
        toPythonUsing("LLSD_NOTATION",
                      [](const LLSD& sd, std::ostream& out)
        { LLSDSerialize::serialize(sd, out, LLSDSerialize::LLSD_NOTATION); 
}

TEST_CASE_FIXTURE(sd_xml_data, "test_5")
{

        set_test_name("to Python using LLSDSerialize::serialize(LLSD_BINARY)");
        toPythonUsing("LLSD_BINARY",
                      [](const LLSD& sd, std::ostream& out)
        { LLSDSerialize::serialize(sd, out, LLSDSerialize::LLSD_BINARY); 
}

TEST_CASE_FIXTURE(sd_xml_data, "test_6")
{

        set_test_name("to Python using LLSDSerialize::toXML()");
        toPythonUsing("toXML()", LLSDSerialize::toXML);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_7")
{

        set_test_name("to Python using LLSDSerialize::toNotation()");
        toPythonUsing("toNotation()", LLSDSerialize::toNotation);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_8")
{

        set_test_name("to Python using LLSDSerialize::toBinary()");
        // We don't expect this to work because, without a header,
        // llsd.parse() will assume notation rather than binary.
        toPythonUsing("toBinary()", LLSDSerialize::toBinary);
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_8")
{

        set_test_name("from Python XML using LLSDSerialize::deserialize()");
        fromPythonUsing("format_xml");
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_9")
{

        set_test_name("from Python notation using LLSDSerialize::deserialize()");
        fromPythonUsing("format_notation");
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_10")
{

        set_test_name("from Python binary using LLSDSerialize::deserialize()");
        fromPythonUsing("format_binary");
    
}

TEST_CASE_FIXTURE(sd_xml_data, "test_11")
{

        set_test_name("from Python XML using fromXML()");
        // fromXML()'s optional 3rd param isn't max_bytes, it's emit_errors
        fromPythonUsing("format_xml",
                        [](std::istream& istr, LLSD& data, llssize)
                        { return LLSDSerialize::fromXML(data, istr) > 0; 
}

TEST_CASE_FIXTURE(sd_xml_data, "test_12")
{

        set_test_name("from Python notation using fromNotation()");
        fromPythonUsing("format_notation",
                        [](std::istream& istr, LLSD& data, llssize max_bytes)
                        { return LLSDSerialize::fromNotation(data, istr, max_bytes) > 0; 
}

TEST_CASE_FIXTURE(sd_xml_data, "test_13")
{

        set_test_name("from Python binary using fromBinary()");
        // We don't expect this to work because format_binary() emits a
        // header, but fromBinary() won't recognize a header.
        fromPythonUsing("format_binary",
                        [](std::istream& istr, LLSD& data, llssize max_bytes)
                        { return LLSDSerialize::fromBinary(data, istr, max_bytes) > 0; 
}

} // TEST_SUITE

