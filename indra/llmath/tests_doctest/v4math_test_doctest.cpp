// ---------------------------------------------------------------------------
// Auto-generated from v4math_test.cpp at 2025-10-17T19:55:29+00:00
// Generated by gen_tut_to_doctest.py
// ---------------------------------------------------------------------------
#include "doctest.h"
#include "indra/test/ll_doctest_helpers.h"
#include "indra/test/tut_compat_doctest.h"
#include "linden_common.h"
#include "llsd.h"
#include "../m4math.h"
#include "../v4math.h"
#include "../llquaternion.h"

/**
 * @file v4math_test.cpp
 * @author Adroit
 * @date 2007-03
 * @brief v4math test cases.
 *
 * $LicenseInfo:firstyear=2007&license=viewerlgpl$
 * Second Life Viewer Source Code
 * Copyright (C) 2010, Linden Research, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation;
 * version 2.1 of the License only.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Linden Research, Inc., 945 Battery Street, San Francisco, CA  94111  USA
 * $/LicenseInfo$
 */



namespace tut
{
    using tut_compat::ensure;
    using tut_compat::ensure_equals;
    using tut_compat::ensure_not;
    using tut_compat::ensure_throws;

        struct v4math_data
        {
        };
} // namespace tut

TUT_SUITE("v4math_test")
{
    TUT_CASE("v4math_test::v4math_object_test_1")
    {
        using namespace tut;
        LLVector4 vec4;
        TUT_CHECK_MSG(((0 == vec4.mV[VX]) && (0 == vec4.mV[VY]) && (0 == vec4.mV[VZ])&& (1.0f == vec4.mV[VW])), "1:LLVector4:Fail to initialize ");
        F32 x = 10.f, y = -2.3f, z = -.023f, w = -2.0f;
        LLVector4 vec4a(x,y,z);
        TUT_CHECK_MSG(((x == vec4a.mV[VX]) && (y == vec4a.mV[VY]) && (z == vec4a.mV[VZ])&& (1.0f == vec4a.mV[VW])), "2:LLVector4:Fail to initialize ");
        LLVector4 vec4b(x,y,z,w);
        TUT_CHECK_MSG(((x == vec4b.mV[VX]) && (y == vec4b.mV[VY]) && (z == vec4b.mV[VZ])&& (w == vec4b.mV[VW])), "3:LLVector4:Fail to initialize ");
        const F32 vec[4] = {.112f ,23.2f, -4.2f, -.0001f};
        LLVector4 vec4c(vec);
        TUT_CHECK_MSG(((vec[0] == vec4c.mV[VX]) && (vec[1] == vec4c.mV[VY]) && (vec[2] == vec4c.mV[VZ])&& (vec[3] == vec4c.mV[VW])), "4:LLVector4:Fail to initialize ");
        LLVector3 vec3(-2.23f,1.01f,42.3f);
        LLVector4 vec4d(vec3);
        TUT_CHECK_MSG(((vec3.mV[VX] == vec4d.mV[VX]) && (vec3.mV[VY] == vec4d.mV[VY]) && (vec3.mV[VZ] == vec4d.mV[VZ])&& (1.f == vec4d.mV[VW])), "5:LLVector4:Fail to initialize ");
        F32 w1 = -.234f;
        LLVector4 vec4e(vec3,w1);
        TUT_CHECK_MSG(((vec3.mV[VX] == vec4e.mV[VX]) && (vec3.mV[VY] == vec4e.mV[VY]) && (vec3.mV[VZ] == vec4e.mV[VZ])&& (w1 == vec4e.mV[VW])), "6:LLVector4:Fail to initialize ");
    }

    TUT_CASE("v4math_test::v4math_object_test_2")
    {
        using namespace tut;
        F32 x = 10.f, y = -2.3f, z = -.023f, w = -2.0f;
        LLVector4 vec4;
        vec4.setVec(x,y,z);
        TUT_CHECK_MSG(((x == vec4.mV[VX]) && (y == vec4.mV[VY]) && (z == vec4.mV[VZ])&& (1.0f == vec4.mV[VW])), "1:setVec:Fail to initialize ");
        vec4.clearVec();
        TUT_CHECK_MSG(((0 == vec4.mV[VX]) && (0 == vec4.mV[VY]) && (0 == vec4.mV[VZ])&& (1.0f == vec4.mV[VW])), "2:clearVec:Fail ");
        vec4.setVec(x,y,z,w);
        TUT_CHECK_MSG(((x == vec4.mV[VX]) && (y == vec4.mV[VY]) && (z == vec4.mV[VZ])&& (w == vec4.mV[VW])), "3:setVec:Fail to initialize ");
        vec4.zeroVec();
        TUT_CHECK_MSG(((0 == vec4.mV[VX]) && (0 == vec4.mV[VY]) && (0 == vec4.mV[VZ])&& (0 == vec4.mV[VW])), "4:zeroVec:Fail ");
        LLVector3 vec3(-2.23f,1.01f,42.3f);
        vec4.clearVec();
        vec4.setVec(vec3);
        TUT_CHECK_MSG(((vec3.mV[VX] == vec4.mV[VX]) && (vec3.mV[VY] == vec4.mV[VY]) && (vec3.mV[VZ] == vec4.mV[VZ])&& (1.f == vec4.mV[VW])), "5:setVec:Fail to initialize ");
        F32 w1 = -.234f;
        vec4.zeroVec();
        vec4.setVec(vec3,w1);
        TUT_CHECK_MSG(((vec3.mV[VX] == vec4.mV[VX]) && (vec3.mV[VY] == vec4.mV[VY]) && (vec3.mV[VZ] == vec4.mV[VZ])&& (w1 == vec4.mV[VW])), "6:setVec:Fail to initialize ");
        const F32 vec[4] = {.112f ,23.2f, -4.2f, -.0001f};
        LLVector4 vec4a;
        vec4a.setVec(vec);
        TUT_CHECK_MSG(((vec[0] == vec4a.mV[VX]) && (vec[1] == vec4a.mV[VY]) && (vec[2] == vec4a.mV[VZ])&& (vec[3] == vec4a.mV[VW])), "7:setVec:Fail to initialize ");
    }

    TUT_CASE("v4math_test::v4math_object_test_3")
    {
        using namespace tut;
        F32 x = 10.f, y = -2.3f, z = -.023f;
        LLVector4 vec4(x,y,z);
        TUT_CHECK_MSG(is_approx_equal(vec4.magVec(), (F32) sqrt(x*x + y*y + z*z)), "magVec:Fail ");
        TUT_CHECK_MSG(is_approx_equal(vec4.magVecSquared(), (x*x + y*y + z*z)), "magVecSquared:Fail ");
    }

    TUT_CASE("v4math_test::v4math_object_test_4")
    {
        using namespace tut;
        F32 x = 10.f, y = -2.3f, z = -.023f;
        LLVector4 vec4(x,y,z);
        F32 mag = vec4.normVec();
        mag = 1.f/ mag;
        TUT_CHECK_MSG(is_approx_equal(mag*x,vec4.mV[VX]) && is_approx_equal(mag*y, vec4.mV[VY])&& is_approx_equal(mag*z, vec4.mV[VZ]), "1:normVec: Fail ");
        x = 0.000000001f, y = 0.000000001f, z = 0.000000001f;
        vec4.clearVec();
        vec4.setVec(x,y,z);
        mag = vec4.normVec();
        TUT_CHECK_MSG(is_approx_equal(mag*x,vec4.mV[VX]) && is_approx_equal(mag*y, vec4.mV[VY])&& is_approx_equal(mag*z, vec4.mV[VZ]), "2:normVec: Fail ");
    }

    TUT_CASE("v4math_test::v4math_object_test_5")
    {
        using namespace tut;
        F32 x = 10.f, y = -2.3f, z = -.023f, w = -2.0f;
        LLVector4 vec4(x,y,z,w);
        vec4.abs();
        TUT_CHECK_MSG(((x == vec4.mV[VX]) && (-y == vec4.mV[VY]) && (-z == vec4.mV[VZ])&& (-w == vec4.mV[VW])), "abs:Fail ");
        vec4.clearVec();
        TUT_CHECK_MSG((true == vec4.isExactlyClear()), "isExactlyClear:Fail ");
        vec4.zeroVec();
        TUT_CHECK_MSG((true == vec4.isExactlyZero()), "isExactlyZero:Fail ");
    }

    TUT_CASE("v4math_test::v4math_object_test_6")
    {
        using namespace tut;
        F32 x = 10.f, y = -2.3f, z = -.023f, w = -2.0f;
        LLVector4 vec4(x,y,z,w),vec4a;
        vec4a = vec4.scaleVec(vec4);
        TUT_CHECK_MSG((is_approx_equal(x*x, vec4a.mV[VX]) && is_approx_equal(y*y, vec4a.mV[VY]) && is_approx_equal(z*z, vec4a.mV[VZ])&& is_approx_equal(w*w, vec4a.mV[VW])), "scaleVec:Fail ");
    }

    TUT_CASE("v4math_test::v4math_object_test_7")
    {
        using namespace tut;
        F32 x = 10.f, y = -2.3f, z = -.023f, w = -2.0f;
        LLVector4 vec4(x,y,z,w);
        TUT_CHECK_MSG(( x ==  vec4[0]), "1:operator [] failed ");
        TUT_CHECK_MSG(( y ==  vec4[1]), "2:operator [] failed ");
        TUT_CHECK_MSG(( z ==  vec4[2]), "3:operator [] failed ");
        TUT_CHECK_MSG(( w ==  vec4[3]), "4:operator [] failed ");
        x = 23.f, y = -.2361f, z = 3.25;
        vec4.setVec(x,y,z);
        F32 &ref1 = vec4[0];
        TUT_CHECK_MSG(( ref1 ==  vec4[0]), "5:operator [] failed ");
        F32 &ref2 = vec4[1];
        TUT_CHECK_MSG(( ref2 ==  vec4[1]), "6:operator [] failed ");
        F32 &ref3 = vec4[2];
        TUT_CHECK_MSG(( ref3 ==  vec4[2]), "7:operator [] failed ");
        F32 &ref4 = vec4[3];
        TUT_CHECK_MSG(( ref4 ==  vec4[3]), "8:operator [] failed ");
    }

    TUT_CASE("v4math_test::v4math_object_test_8")
    {
        using namespace tut;
        F32 x = 10.f, y = -2.3f, z = -.023f, w = -2.0f;
        const  F32 val[16] = {
            1.f,  2.f,   3.f,    0.f,
            .34f, .1f,   -.5f,   0.f,
            2.f,  1.23f, 1.234f, 0.f,
            .89f, 0.f,   0.f,    0.f
        };
        LLMatrix4 mat(val);
        LLVector4 vec4(x,y,z,w),vec4a;
        vec4.rotVec(mat);
        vec4a.setVec(x,y,z,w);
        vec4a.rotVec(mat);
        TUT_ENSURE_EQ("1:rotVec: Fail ", vec4a, vec4);
        F32 a = 2.32f, b = -23.2f, c = -34.1112f, d = 1.010112f;
        LLQuaternion q(a,b,c,d);
        LLVector4 vec4b(a,b,c,d),vec4c;
        vec4b.rotVec(q);
        vec4c.setVec(a, b, c, d);
        vec4c.rotVec(q);
        TUT_ENSURE_EQ("2:rotVec: Fail ", vec4b, vec4c);
    }

    TUT_CASE("v4math_test::v4math_object_test_9")
    {
        using namespace tut;
        F32 x = 10.f, y = -2.3f, z = -.023f, w = -2.0f;
        LLVector4 vec4(x,y,z,w),vec4a;;
        std::ostringstream stream1, stream2;
        stream1 << vec4;
        vec4a.setVec(x,y,z,w);
        stream2 << vec4a;
        TUT_CHECK_MSG((stream1.str() == stream2.str()), "operator << failed");
    }

    TUT_CASE("v4math_test::v4math_object_test_10")
    {
        using namespace tut;
        F32 x1 = 1.f, y1 = 2.f, z1 = -1.1f, w1 = .23f;
        F32 x2 = 1.2f, y2 = 2.5f, z2 = 1.f, w2 = 1.3f;
        LLVector4 vec4(x1,y1,z1,w1),vec4a(x2,y2,z2,w2),vec4b;
        vec4b = vec4a + vec4;
        TUT_CHECK_MSG((is_approx_equal(x1+x2,vec4b.mV[VX]) && is_approx_equal(y1+y2,vec4b.mV[VY]) && is_approx_equal(z1+z2,vec4b.mV[VZ])), "1:operator+:Fail to initialize ");
        x1 = -2.45f, y1 = 2.1f, z1 = 3.0f;
        vec4.clearVec();
        vec4a.clearVec();
        vec4.setVec(x1,y1,z1);
        vec4a +=vec4;
        TUT_ENSURE_EQ("2:operator+=: Fail to initialize", vec4a, vec4);
        vec4a += vec4;
        TUT_CHECK_MSG((is_approx_equal(2*x1,vec4a.mV[VX]) && is_approx_equal(2*y1,vec4a.mV[VY]) && is_approx_equal(2*z1,vec4a.mV[VZ])), "3:operator+=:Fail to initialize ");
    }

    TUT_CASE("v4math_test::v4math_object_test_11")
    {
        using namespace tut;
        F32 x1 = 1.f, y1 = 2.f, z1 = -1.1f, w1 = .23f;
        F32 x2 = 1.2f, y2 = 2.5f, z2 = 1.f, w2 = 1.3f;
        LLVector4 vec4(x1,y1,z1,w1),vec4a(x2,y2,z2,w2),vec4b;
        vec4b = vec4a - vec4;
        TUT_CHECK_MSG((is_approx_equal(x2-x1,vec4b.mV[VX]) && is_approx_equal(y2-y1,vec4b.mV[VY]) && is_approx_equal(z2-z1,vec4b.mV[VZ])), "1:operator-:Fail to initialize ");
        x1 = -2.45f, y1 = 2.1f, z1 = 3.0f;
        vec4.clearVec();
        vec4a.clearVec();
        vec4.setVec(x1,y1,z1);
        vec4a -=vec4;
        TUT_ENSURE_EQ("2:operator-=: Fail to initialize", vec4a, -vec4);
        vec4a -=vec4;
        TUT_CHECK_MSG((is_approx_equal(-2*x1,vec4a.mV[VX]) && is_approx_equal(-2*y1,vec4a.mV[VY]) && is_approx_equal(-2*z1,vec4a.mV[VZ])), "3:operator-=:Fail to initialize ");
    }

    TUT_CASE("v4math_test::v4math_object_test_12")
    {
        using namespace tut;
        F32 x1 = 1.f, y1 = 2.f, z1 = -1.1f;
        F32 x2 = 1.2f, y2 = 2.5f, z2 = 1.f;
        LLVector4 vec4(x1,y1,z1),vec4a(x2,y2,z2);
        F32 res = vec4 * vec4a;
        TUT_CHECK_MSG(is_approx_equal(res, x1*x2 + y1*y2 + z1*z2), "1:operator* failed ");
        vec4a.clearVec();
        F32 mulVal = 4.2f;
        vec4a = vec4 * mulVal;
        TUT_CHECK_MSG(is_approx_equal(x1*mulVal,vec4a.mV[VX]) && is_approx_equal(y1*mulVal, vec4a.mV[VY])&& is_approx_equal(z1*mulVal, vec4a.mV[VZ]), "2:operator* failed ");
        vec4a.clearVec();
        vec4a = mulVal *  vec4 ;
        TUT_CHECK_MSG(is_approx_equal(x1*mulVal, vec4a.mV[VX]) && is_approx_equal(y1*mulVal, vec4a.mV[VY])&& is_approx_equal(z1*mulVal, vec4a.mV[VZ]), "3:operator* failed ");
        vec4 *= mulVal;
        TUT_CHECK_MSG(is_approx_equal(x1*mulVal, vec4.mV[VX]) && is_approx_equal(y1*mulVal, vec4.mV[VY])&& is_approx_equal(z1*mulVal, vec4.mV[VZ]), "4:operator*= failed ");
    }

    TUT_CASE("v4math_test::v4math_object_test_13")
    {
        using namespace tut;
        F32 x1 = 1.f, y1 = 2.f, z1 = -1.1f;
        F32 x2 = 1.2f, y2 = 2.5f, z2 = 1.f;
        LLVector4 vec4(x1,y1,z1),vec4a(x2,y2,z2),vec4b;
        vec4b = vec4 % vec4a;
        TUT_CHECK_MSG(is_approx_equal(y1*z2 - y2*z1, vec4b.mV[VX]) && is_approx_equal(z1*x2 -z2*x1, vec4b.mV[VY]) && is_approx_equal(x1*y2-x2*y1, vec4b.mV[VZ]), "1:operator% failed ");
        vec4 %= vec4a;
        TUT_ENSURE_EQ("operator%= failed ", vec4, vec4b);
    }

    TUT_CASE("v4math_test::v4math_object_test_14")
    {
        using namespace tut;
        F32 x = 1.f, y = 2.f, z = -1.1f,div = 4.2f;
        F32 t = 1.f / div;
        LLVector4 vec4(x,y,z), vec4a;
        vec4a = vec4/div;
        TUT_CHECK_MSG(is_approx_equal(x*t, vec4a.mV[VX]) && is_approx_equal(y*t, vec4a.mV[VY])&& is_approx_equal(z*t, vec4a.mV[VZ]), "1:operator/ failed ");
        x = 1.23f, y = 4.f, z = -2.32f;
        vec4.clearVec();
        vec4a.clearVec();
        vec4.setVec(x,y,z);
        vec4a = vec4/div;
        TUT_CHECK_MSG(is_approx_equal(x*t, vec4a.mV[VX]) && is_approx_equal(y*t, vec4a.mV[VY])&& is_approx_equal(z*t, vec4a.mV[VZ]), "2:operator/ failed ");
        vec4 /= div;
        TUT_CHECK_MSG(is_approx_equal(x*t, vec4.mV[VX]) && is_approx_equal(y*t, vec4.mV[VY])&& is_approx_equal(z*t, vec4.mV[VZ]), "3:operator/ failed ");
    }

    TUT_CASE("v4math_test::v4math_object_test_15")
    {
        using namespace tut;
        F32 x = 1.f, y = 2.f, z = -1.1f;
        LLVector4 vec4(x,y,z), vec4a;
        TUT_CHECK_MSG((vec4 != vec4a), "operator!= failed ");
        vec4a = vec4;
        TUT_CHECK_MSG((vec4 ==vec4a), "operator== failed ");
    }

    TUT_CASE("v4math_test::v4math_object_test_16")
    {
        using namespace tut;
        F32 x = 1.f, y = 2.f, z = -1.1f;
        LLVector4 vec4(x,y,z), vec4a;
        vec4a = - vec4;
        TUT_CHECK_MSG((vec4 == - vec4a), "operator- failed ");
    }

    TUT_CASE("v4math_test::v4math_object_test_17")
    {
        using namespace tut;
        F32 x = 1.f, y = 2.f, z = -1.1f,epsilon = .23425f;
        LLVector4 vec4(x,y,z), vec4a(x,y,z);
        TUT_CHECK_MSG((true == are_parallel(vec4a,vec4,epsilon)), "1:are_parallel: Fail ");
        x = 21.f, y = 12.f, z = -123.1f;
        vec4a.clearVec();
        vec4a.setVec(x,y,z);
        TUT_CHECK_MSG((false == are_parallel(vec4a,vec4,epsilon)), "2:are_parallel: Fail ");
    }

    TUT_CASE("v4math_test::v4math_object_test_18")
    {
        using namespace tut;
        F32 x = 1.f, y = 2.f, z = -1.1f;
        F32 angle1, angle2;
        LLVector4 vec4(x,y,z), vec4a(x,y,z);
        angle1 = angle_between(vec4, vec4a);
        vec4.normVec();
        vec4a.normVec();
        angle2 = acos(vec4 * vec4a);
        TUT_CHECK_MSG((angle1) == doctest::Approx(angle2).epsilon(8), "1:angle_between: Fail ");
        F32 x1 = 21.f, y1 = 2.23f, z1 = -1.1f;
        LLVector4 vec4b(x,y,z), vec4c(x1,y1,z1);
        angle1 = angle_between(vec4b, vec4c);
        vec4b.normVec();
        vec4c.normVec();
        angle2 = acos(vec4b * vec4c);
        TUT_CHECK_MSG((angle1) == doctest::Approx(angle2).epsilon(8), "2:angle_between: Fail ");
    }

    TUT_CASE("v4math_test::v4math_object_test_19")
    {
        using namespace tut;
        F32 x1 =-2.3f, y1 = 2.f,z1 = 1.2f, x2 = 1.3f, y2 = 1.f, z2 = 1.f;
        F32 val1,val2;
        LLVector4 vec4(x1,y1,z1),vec4a(x2,y2,z2);
        val1 = dist_vec(vec4,vec4a);
        val2 = (F32) sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)* (y1 - y2) + (z1 - z2)* (z1 -z2));
        TUT_ENSURE_EQ("dist_vec: Fail ", val2, val1);
        val1 = dist_vec_squared(vec4,vec4a);
        val2 =((x1 - x2)*(x1 - x2) + (y1 - y2)* (y1 - y2) + (z1 - z2)* (z1 -z2));
        TUT_ENSURE_EQ("dist_vec_squared: Fail ", val2, val1);
    }

    TUT_CASE("v4math_test::v4math_object_test_20")
    {
        using namespace tut;
        F32 x1 =-2.3f, y1 = 2.f,z1 = 1.2f, w1 = -.23f, x2 = 1.3f, y2 = 1.f, z2 = 1.f,w2 = .12f;
        F32 val = 2.3f,val1,val2,val3,val4;
        LLVector4 vec4(x1,y1,z1,w1),vec4a(x2,y2,z2,w2);
        val1 = x1 + (x2 - x1)* val;
        val2 = y1 + (y2 - y1)* val;
        val3 = z1 + (z2 - z1)* val;
        val4 = w1 + (w2 - w1)* val;
        LLVector4 vec4b = lerp(vec4,vec4a,val);
        LLVector4 check(val1, val2, val3, val4);
        TUT_ENSURE_EQ("lerp failed", check, vec4b);
    }

    TUT_CASE("v4math_test::v4math_object_test_21")
    {
        using namespace tut;
        F32 x = 1.f, y = 2.f, z = -1.1f;
        LLVector4 vec4(x,y,z);
        LLVector3 vec3 = vec4to3(vec4);
        TUT_CHECK_MSG(((x == vec3.mV[VX])&& (y == vec3.mV[VY]) && (z == vec3.mV[VZ])), "vec4to3 failed");
        LLVector4 vec4a = vec3to4(vec3);
        TUT_ENSURE_EQ("vec3to4 failed", vec4a, vec4);
    }

    TUT_CASE("v4math_test::v4math_object_test_22")
    {
        using namespace tut;
        F32 x = 1.f, y = 2.f, z = -1.1f;
        LLVector4 vec4(x,y,z);
        LLSD llsd = vec4.getValue();
        LLVector3 vec3(llsd);
        LLVector4 vec4a = vec3to4(vec3);
        TUT_ENSURE_EQ("getValue failed", vec4a, vec4);
    }
}
