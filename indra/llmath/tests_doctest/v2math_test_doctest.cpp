// ---------------------------------------------------------------------------
// Auto-generated from v2math_test.cpp at 2025-10-17T19:55:29+00:00
// Generated by gen_tut_to_doctest.py
// ---------------------------------------------------------------------------
#include "doctest.h"
#include "indra/test/ll_doctest_helpers.h"
#include "indra/test/tut_compat_doctest.h"
#include "linden_common.h"
#include "../v2math.h"

/**
 * @file v2math_test.cpp
 * @author Adroit
 * @date 2007-02
 * @brief v2math test cases.
 *
 * $LicenseInfo:firstyear=2007&license=viewerlgpl$
 * Second Life Viewer Source Code
 * Copyright (C) 2010, Linden Research, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation;
 * version 2.1 of the License only.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Linden Research, Inc., 945 Battery Street, San Francisco, CA  94111  USA
 * $/LicenseInfo$
 */




namespace tut
{
    using tut_compat::ensure;
    using tut_compat::ensure_equals;
    using tut_compat::ensure_not;
    using tut_compat::ensure_throws;

        struct v2math_data
        {
        };
} // namespace tut

TUT_SUITE("v2math_test")
{
    TUT_CASE("v2math_test::v2math_object_test_1")
    {
        using namespace tut;
        LLVector2 vec2;
        TUT_CHECK_MSG((0.f == vec2.mV[VX] && 0.f == vec2.mV[VY]), "LLVector2:Fail to initialize ");

        F32 x =2.0f, y = 3.2f ;
        LLVector2 vec3(x,y);
        TUT_CHECK_MSG((x == vec3.mV[VX]) && (y == vec3.mV[VY]), "LLVector2(F32 x, F32 y):Fail to initialize ");

        const F32 vec[2] = {3.2f, 4.5f};
        LLVector2 vec4(vec);
        TUT_CHECK_MSG((vec[0] == vec4.mV[VX]) && (vec[1] == vec4.mV[VY]), "LLVector2(const F32 *vec):Fail to initialize ");

        vec4.clearVec();
        TUT_CHECK_MSG((0.f == vec4.mV[VX] && 0.f == vec4.mV[VY]), "clearVec():Fail to clean the values ");

        vec3.zeroVec();
        TUT_CHECK_MSG((0.f == vec3.mV[VX] && 0.f == vec3.mV[VY]), "zeroVec():Fail to fill the zero ");
    }

    TUT_CASE("v2math_test::v2math_object_test_2")
    {
        using namespace tut;
        F32 x = 123.356f, y = 2387.453f;
        LLVector2 vec2,vec3;
        vec2.setVec(x, y);
        TUT_CHECK_MSG((x == vec2.mV[VX]) && (y == vec2.mV[VY]), "1:setVec: Fail  ");

        vec3.setVec(vec2);
        TUT_CHECK_MSG((vec2 == vec3), "2:setVec: Fail   ");

        vec3.zeroVec();
        const F32 vec[2] = {3.24653f, 457653.4f};
        vec3.setVec(vec);
        TUT_CHECK_MSG((vec[0] == vec3.mV[VX]) && (vec[1] == vec3.mV[VY]), "3:setVec: Fail  ");
    }

    TUT_CASE("v2math_test::v2math_object_test_3")
    {
        using namespace tut;
        F32 x = 2.2345f, y = 3.5678f ;
        LLVector2 vec2(x,y);
        TUT_CHECK_MSG(is_approx_equal(vec2.magVecSquared(), (x*x + y*y)), "magVecSquared:Fail ");
        TUT_CHECK_MSG(is_approx_equal(vec2.magVec(), (F32) sqrt(x*x + y*y)), "magVec:Fail ");
    }

    TUT_CASE("v2math_test::v2math_object_test_4")
    {
        using namespace tut;
        F32 x =-2.0f, y = -3.0f ;
        LLVector2 vec2(x,y);
        TUT_ENSURE_EQ("abs():Fail", vec2.abs(), true);
        TUT_CHECK_MSG(is_approx_equal(vec2.mV[VX], 2.f), "abs() x");
        TUT_CHECK_MSG(is_approx_equal(vec2.mV[VY], 3.f), "abs() y");

        TUT_CHECK_MSG(false == vec2.isNull(), "isNull():Fail ");   //Returns true if vector has a _very_small_ length

        x =.00000001f, y = .000001001f;
        vec2.setVec(x, y);
        TUT_CHECK_MSG(true == vec2.isNull(), "isNull(): Fail ");
    }

    TUT_CASE("v2math_test::v2math_object_test_5")
    {
        using namespace tut;
        F32 x =1.f, y = 2.f;
        LLVector2 vec2(x, y), vec3;
        vec3 = vec3.scaleVec(vec2);
        TUT_CHECK_MSG(vec3.mV[VX] == 0. && vec3.mV[VY] == 0., "scaleVec: Fail ");
        TUT_CHECK_MSG(true == vec3.isExactlyZero(), "isExactlyZero(): Fail");

        vec3.setVec(2.f, 1.f);
        vec3 = vec3.scaleVec(vec2);
        TUT_CHECK_MSG((2.f == vec3.mV[VX]) && (2.f == vec3.mV[VY]), "scaleVec: Fail ");
        TUT_CHECK_MSG(false == vec3.isExactlyZero(), "isExactlyZero():Fail");
    }

    TUT_CASE("v2math_test::v2math_object_test_6")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f, x2 = -2.3f, y2 = 1.11f;
        F32 val1, val2;
        LLVector2 vec2(x1, y1), vec3(x2, y2), vec4;
        vec4 = vec2 + vec3 ;
        val1 = x1+x2;
        val2 = y1+y2;
        TUT_CHECK_MSG((val1 == vec4.mV[VX]) && ((val2 == vec4.mV[VY])), "1:operator+ failed");

        vec2.clearVec();
        vec3.clearVec();
        x1 = -.235f, y1 = -24.32f,  x2 = -2.3f, y2 = 1.f;
        vec2.setVec(x1, y1);
        vec3.setVec(x2, y2);
        vec4 = vec2 + vec3;
        val1 = x1+x2;
        val2 = y1+y2;
        TUT_CHECK_MSG((val1 == vec4.mV[VX]) && ((val2 == vec4.mV[VY])), "2:operator+ failed");
    }

    TUT_CASE("v2math_test::v2math_object_test_7")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f,  x2 = -2.3f, y2 = 1.11f;
        F32 val1, val2;
        LLVector2 vec2(x1, y1), vec3(x2, y2), vec4;
        vec4 = vec2 - vec3 ;
        val1 = x1-x2;
        val2 = y1-y2;
        TUT_CHECK_MSG((val1 == vec4.mV[VX]) && ((val2 == vec4.mV[VY])), "1:operator- failed");

        vec2.clearVec();
        vec3.clearVec();
        vec4.clearVec();
        x1 = -.235f, y1 = -24.32f,  x2 = -2.3f, y2 = 1.f;
        vec2.setVec(x1, y1);
        vec3.setVec(x2, y2);
        vec4 = vec2 - vec3;
        val1 = x1-x2;
        val2 = y1-y2;
        TUT_CHECK_MSG((val1 == vec4.mV[VX]) && ((val2 == vec4.mV[VY])), "2:operator- failed");
    }

    TUT_CASE("v2math_test::v2math_object_test_8")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f,  x2 = -2.3f, y2 = 1.11f;
        F32 val1, val2;
        LLVector2 vec2(x1, y1), vec3(x2, y2);
        val1 = vec2 * vec3;
        val2 = x1*x2 + y1*y2;
        TUT_CHECK_MSG((val1 == val2), "1:operator* failed");

        vec3.clearVec();
        F32 mulVal = 4.332f;
        vec3 = vec2 * mulVal;
        val1 = x1*mulVal;
        val2 = y1*mulVal;
        TUT_CHECK_MSG((val1 == vec3.mV[VX]) && (val2 == vec3.mV[VY]), "2:operator* failed");

        vec3.clearVec();
        vec3 = mulVal * vec2;
        TUT_CHECK_MSG((val1 == vec3.mV[VX]) && (val2 == vec3.mV[VY]), "3:operator* failed");
    }

    TUT_CASE("v2math_test::v2math_object_test_9")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f, div = 3.2f;
        F32 val1, val2;
        LLVector2 vec2(x1, y1), vec3;
        vec3 = vec2 / div;
        val1 = x1 / div;
        val2 = y1 / div;
        TUT_CHECK_MSG(is_approx_equal(val1, vec3.mV[VX]) && is_approx_equal(val2, vec3.mV[VY]), "1:operator/ failed");

        vec3.clearVec();
        x1 = -.235f, y1 = -24.32f, div = -2.2f;
        vec2.setVec(x1, y1);
        vec3 = vec2 / div;
        val1 = x1 / div;
        val2 = y1 / div;
        TUT_CHECK_MSG(is_approx_equal(val1, vec3.mV[VX]) && is_approx_equal(val2, vec3.mV[VY]), "2:operator/ failed");
    }

    TUT_CASE("v2math_test::v2math_object_test_10")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f,  x2 = -2.3f, y2 = 1.11f;
        F32 val1, val2;
        LLVector2 vec2(x1, y1), vec3(x2, y2), vec4;
        vec4 = vec2 % vec3;
        val1 = x1*y2 - x2*y1;
        val2 = y1*x2 - y2*x1;
        TUT_CHECK_MSG((val1 == vec4.mV[VX]) && (val2 == vec4.mV[VY]), "1:operator% failed");

        vec2.clearVec();
        vec3.clearVec();
        vec4.clearVec();
        x1 = -.235f, y1 = -24.32f,  x2 = -2.3f, y2 = 1.f;
        vec2.setVec(x1, y1);
        vec3.setVec(x2, y2);
        vec4 = vec2 % vec3;
        val1 = x1*y2 - x2*y1;
        val2 = y1*x2 - y2*x1;
        TUT_CHECK_MSG((val1 == vec4.mV[VX]) && (val2 == vec4.mV[VY]), "2:operator% failed");
    }

    TUT_CASE("v2math_test::v2math_object_test_11")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f;
        LLVector2 vec2(x1, y1), vec3(x1, y1);
        TUT_CHECK_MSG((vec2 == vec3), "1:operator== failed");

        vec2.clearVec();
        vec3.clearVec();
        x1 = -.235f, y1 = -24.32f;
        vec2.setVec(x1, y1);
        vec3.setVec(vec2);
        TUT_CHECK_MSG((vec2 == vec3), "2:operator== failed");
    }

    TUT_CASE("v2math_test::v2math_object_test_12")
    {
        using namespace tut;
        F32 x1 = 1.f, y1 = 2.f,x2 = 2.332f, y2 = -1.23f;
        LLVector2 vec2(x1, y1), vec3(x2, y2);
        TUT_CHECK_MSG((vec2 != vec3), "1:operator!= failed");

        vec2.clearVec();
        vec3.clearVec();
        vec2.setVec(x1, y1);
        vec3.setVec(vec2);
        TUT_CHECK_MSG((false == (vec2 != vec3)), "2:operator!= failed");
    }

    TUT_CASE("v2math_test::v2math_object_test_13")
    {
        using namespace tut;
        F32 x1 = 1.f, y1 = 2.f,x2 = 2.332f, y2 = -1.23f;
        F32 val1, val2;
        LLVector2 vec2(x1, y1), vec3(x2, y2);
        vec2 +=vec3;
        val1 = x1+x2;
        val2 = y1+y2;
        TUT_CHECK_MSG((val1 == vec2.mV[VX]) && (val2 == vec2.mV[VY]), "1:operator+= failed");

        vec2.setVec(x1, y1);
        vec2 -=vec3;
        val1 = x1-x2;
        val2 = y1-y2;
        TUT_CHECK_MSG((val1 == vec2.mV[VX]) && (val2 == vec2.mV[VY]), "2:operator-= failed");

        vec2.clearVec();
        vec3.clearVec();
        x1 = -21.000466f, y1 = 2.98382f,x2 = 0.332f, y2 = -01.23f;
        vec2.setVec(x1, y1);
        vec3.setVec(x2, y2);
        vec2 +=vec3;
        val1 = x1+x2;
        val2 = y1+y2;
        TUT_CHECK_MSG((val1 == vec2.mV[VX]) && (val2 == vec2.mV[VY]), "3:operator+= failed");

        vec2.setVec(x1, y1);
        vec2 -=vec3;
        val1 = x1-x2;
        val2 = y1-y2;
        TUT_CHECK_MSG(is_approx_equal(val1, vec2.mV[VX]) && is_approx_equal(val2, vec2.mV[VY]), "4:operator-= failed");
    }

    TUT_CASE("v2math_test::v2math_object_test_14")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f;
        F32 val1, val2, mulVal = 4.332f;
        LLVector2 vec2(x1, y1);
        vec2 /=mulVal;
        val1 = x1 / mulVal;
        val2 = y1 / mulVal;
        TUT_CHECK_MSG(is_approx_equal(val1, vec2.mV[VX]) && is_approx_equal(val2, vec2.mV[VY]), "1:operator/= failed");

        vec2.clearVec();
        x1 = .213f, y1 = -2.34f, mulVal = -.23f;
        vec2.setVec(x1, y1);
        vec2 /=mulVal;
        val1 = x1 / mulVal;
        val2 = y1 / mulVal;
        TUT_CHECK_MSG(is_approx_equal(val1, vec2.mV[VX]) && is_approx_equal(val2, vec2.mV[VY]), "2:operator/= failed");
    }

    TUT_CASE("v2math_test::v2math_object_test_15")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f;
        F32 val1, val2, mulVal = 4.332f;
        LLVector2 vec2(x1, y1);
        vec2 *=mulVal;
        val1 = x1*mulVal;
        val2 = y1*mulVal;
        TUT_CHECK_MSG((val1 == vec2.mV[VX]) && (val2 == vec2.mV[VY]), "1:operator*= failed");

        vec2.clearVec();
        x1 = .213f, y1 = -2.34f, mulVal = -.23f;
        vec2.setVec(x1, y1);
        vec2 *=mulVal;
        val1 = x1*mulVal;
        val2 = y1*mulVal;
        TUT_CHECK_MSG((val1 == vec2.mV[VX]) && (val2 == vec2.mV[VY]), "2:operator*= failed");
    }

    TUT_CASE("v2math_test::v2math_object_test_16")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f,  x2 = -2.3f, y2 = 1.11f;
        F32 val1, val2;
        LLVector2 vec2(x1, y1), vec3(x2, y2);
        vec2 %= vec3;
        val1 = x1*y2 - x2*y1;
        val2 = y1*x2 - y2*x1;
        TUT_CHECK_MSG((val1 == vec2.mV[VX]) && (val2 == vec2.mV[VY]), "1:operator%= failed");
    }

    TUT_CASE("v2math_test::v2math_object_test_17")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f;
        LLVector2 vec2(x1, y1),vec3;
        vec3 = -vec2;
        TUT_CHECK_MSG((-vec3 == vec2), "1:operator- failed");
    }

    TUT_CASE("v2math_test::v2math_object_test_18")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f;
        std::ostringstream stream1, stream2;
        LLVector2 vec2(x1, y1),vec3;
        stream1 << vec2;
        vec3.setVec(x1, y1);
        stream2 << vec3;
        TUT_CHECK_MSG((stream1.str() == stream2.str()), "1:operator << failed");
    }

    TUT_CASE("v2math_test::v2math_object_test_19")
    {
        using namespace tut;
        F32 x1 =1.0f, y1 = 2.0f, x2 = -.32f, y2 = .2234f;
        LLVector2 vec2(x1, y1),vec3(x2, y2);
        TUT_CHECK_MSG((vec3 < vec2), "1:operator < failed");

        x1 = 1.0f, y1 = 2.0f, x2 = 1.0f, y2 = 3.2234f;
        vec2.setVec(x1, y1);
        vec3.setVec(x2, y2);
        TUT_CHECK_MSG((false == (vec3 < vec2)), "2:operator < failed");
    }

    TUT_CASE("v2math_test::v2math_object_test_20")
    {
        using namespace tut;
        F32 x1 =1.0f, y1 = 2.0f;
        LLVector2 vec2(x1, y1);
        TUT_CHECK_MSG(( x1 ==  vec2[0]), "1:operator [] failed");
        TUT_CHECK_MSG(( y1 ==  vec2[1]), "2:operator [] failed");

        vec2.clearVec();
        x1 = 23.0f, y1 = -.2361f;
        vec2.setVec(x1, y1);
        F32 ref1 = vec2[0];
        TUT_CHECK_MSG(( ref1 ==  x1), "3:operator [] failed");
        F32 ref2 = vec2[1];
        TUT_CHECK_MSG(( ref2 ==  y1), "4:operator [] failed");
    }

    TUT_CASE("v2math_test::v2math_object_test_21")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f, x2 = -.32f, y2 = .2234f;
        F32 val1, val2;
        LLVector2 vec2(x1, y1),vec3(x2, y2);
        val1 = dist_vec_squared2D(vec2, vec3);
        val2 = (x1 - x2)*(x1 - x2) + (y1 - y2)* (y1 - y2);
        TUT_ENSURE_EQ("dist_vec_squared2D values are not equal", val2, val1);

        val1 = dist_vec_squared(vec2, vec3);
        TUT_ENSURE_EQ("dist_vec_squared values are not equal", val2, val1);

        val1 =  dist_vec(vec2, vec3);
        val2 = (F32) sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)* (y1 - y2));
        TUT_ENSURE_EQ("dist_vec values are not equal", val2, val1);
    }

    TUT_CASE("v2math_test::v2math_object_test_22")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f, x2 = -.32f, y2 = .2234f,fVal = .0121f;
        F32 val1, val2;
        LLVector2 vec2(x1, y1),vec3(x2, y2);
        LLVector2 vec4 = lerp(vec2, vec3, fVal);
        val1 = x1 + (x2 - x1) * fVal;
        val2 = y1 + (y2 - y1) * fVal;
        TUT_CHECK_MSG(((val1 == vec4.mV[VX]) && (val2 == vec4.mV[VY])), "lerp values are not equal");
    }

    TUT_CASE("v2math_test::v2math_object_test_23")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f;
        F32 val1, val2;
        LLVector2 vec2(x1, y1);

        F32 vecMag = vec2.normVec();
        F32 mag = (F32) sqrt(x1*x1 + y1*y1);

        F32 oomag = 1.f / mag;
        val1 = x1 * oomag;
        val2 = y1 * oomag;

        TUT_CHECK_MSG(is_approx_equal(val1, vec2.mV[VX]) && is_approx_equal(val2, vec2.mV[VY]) && is_approx_equal(vecMag, mag), "normVec failed");

        x1 =.00000001f, y1 = 0.f;

        vec2.setVec(x1, y1);
        vecMag = vec2.normVec();
        TUT_CHECK_MSG(0. == vec2.mV[VX] && 0. == vec2.mV[VY] && vecMag == 0., "normVec failed should be 0.");
    }
}
