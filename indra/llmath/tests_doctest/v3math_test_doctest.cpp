// ---------------------------------------------------------------------------
// Auto-generated from v3math_test.cpp at 2025-10-17T12:56:18+00:00
// Generated by gen_tut_to_doctest.py
// ---------------------------------------------------------------------------
#include "doctest.h"
#include "indra/test/ll_doctest_helpers.h"
#include "indra/test/tut_compat_doctest.h"
#include "linden_common.h"
#include "llsd.h"
#include "../v3dmath.h"
#include "../m3math.h"
#include "../v4math.h"
#include "../v3math.h"
#include "../llquaternion.h"
#include "../llquantize.h"

/**
 * @file v3math_test.cpp
 * @author Adroit
 * @date 2007-02
 * @brief v3math test cases.
 *
 * $LicenseInfo:firstyear=2007&license=viewerlgpl$
 * Second Life Viewer Source Code
 * Copyright (C) 2010, Linden Research, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation;
 * version 2.1 of the License only.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Linden Research, Inc., 945 Battery Street, San Francisco, CA  94111  USA
 * $/LicenseInfo$
 */




namespace tut
{
    using tut_compat::ensure;
    using tut_compat::ensure_equals;
    using tut_compat::ensure_not;
    using tut_compat::ensure_throws;

        struct v3math_data
        {
        };
} // namespace tut

TUT_SUITE("v3math_test")
{
    TUT_CASE("v3math_test::v3math_object_test_1")
    {
        using namespace tut;
        LLVector3 vec3;
        TUT_CHECK_MSG(((0.f == vec3.mV[VX]) && (0.f == vec3.mV[VY]) && (0.f == vec3.mV[VZ])), "1:LLVector3:Fail to initialize ");
        F32 x = 2.32f, y = 1.212f, z = -.12f;
        LLVector3 vec3a(x,y,z);
        TUT_CHECK_MSG(((2.32f == vec3a.mV[VX]) && (1.212f == vec3a.mV[VY]) && (-.12f == vec3a.mV[VZ])), "2:LLVector3:Fail to initialize ");
        const F32 vec[3] = {1.2f ,3.2f, -4.2f};
        LLVector3 vec3b(vec);
        TUT_CHECK_MSG(((1.2f == vec3b.mV[VX]) && (3.2f == vec3b.mV[VY]) && (-4.2f == vec3b.mV[VZ])), "3:LLVector3:Fail to initialize ");
    }

    TUT_CASE("v3math_test::v3math_object_test_2")
    {
        using namespace tut;
        F32 x = 2.32f, y = 1.212f, z = -.12f;
        LLVector3 vec3(x,y,z);
        LLVector3d vector3d(vec3);
        LLVector3 vec3a(vector3d);
        TUT_CHECK_MSG(vec3 == vec3a, "1:LLVector3:Fail to initialize ");
        LLVector4 vector4(vec3);
        LLVector3 vec3b(vector4);
        TUT_CHECK_MSG(vec3 == vec3b, "2:LLVector3:Fail to initialize ");
    }

    TUT_CASE("v3math_test::v3math_object_test_3")
    {
        using namespace tut;
        S32 a = 231;
        LLSD llsd(a);
        LLVector3 vec3(llsd);
        LLSD sd = vec3.getValue();
        LLVector3 vec3a(sd);
        TUT_CHECK_MSG((vec3 == vec3a), "1:LLVector3:Fail to initialize ");
    }

    TUT_CASE("v3math_test::v3math_object_test_4")
    {
        using namespace tut;
        S32 a = 231;
        LLSD llsd(a);
        LLVector3 vec3(llsd),vec3a;
        vec3a = vec3;
        TUT_CHECK_MSG((vec3 == vec3a), "1:Operator= Fail to initialize ");
    }

    TUT_CASE("v3math_test::v3math_object_test_5")
    {
        using namespace tut;
        F32 x = 2.32f, y = 1.212f, z = -.12f;
        LLVector3 vec3(x,y,z);
        TUT_CHECK_MSG((true == vec3.isFinite()), "1:isFinite= Fail to initialize ");//need more test cases:
        vec3.clearVec();
        TUT_CHECK_MSG(((0.f == vec3.mV[VX]) && (0.f == vec3.mV[VY]) && (0.f == vec3.mV[VZ])), "2:clearVec:Fail to set values ");
        vec3.setVec(x,y,z);
        TUT_CHECK_MSG(((2.32f == vec3.mV[VX]) && (1.212f == vec3.mV[VY]) && (-.12f == vec3.mV[VZ])), "3:setVec:Fail to set values ");
        vec3.zeroVec();
        TUT_CHECK_MSG(((0.f == vec3.mV[VX]) && (0.f == vec3.mV[VY]) && (0.f == vec3.mV[VZ])), "4:zeroVec:Fail to set values ");
    }

    TUT_CASE("v3math_test::v3math_object_test_6")
    {
        using namespace tut;
        F32 x = 2.32f, y = 1.212f, z = -.12f;
        LLVector3 vec3(x,y,z),vec3a;
        vec3.abs();
        TUT_CHECK_MSG(((x == vec3.mV[VX]) && (y == vec3.mV[VY]) && (-z == vec3.mV[VZ])), "1:abs:Fail ");
        vec3a.setVec(vec3);
        TUT_CHECK_MSG((vec3a == vec3), "2:setVec:Fail to initialize ");
        const F32 vec[3] = {1.2f ,3.2f, -4.2f};
        vec3.clearVec();
        vec3.setVec(vec);
        TUT_CHECK_MSG(((1.2f == vec3.mV[VX]) && (3.2f == vec3.mV[VY]) && (-4.2f == vec3.mV[VZ])), "3:setVec:Fail to initialize ");
        vec3a.clearVec();
        LLVector3d vector3d(vec3);
        vec3a.setVec(vector3d);
        TUT_CHECK_MSG((vec3 == vec3a), "4:setVec:Fail to initialize ");
        LLVector4 vector4(vec3);
        vec3a.clearVec();
        vec3a.setVec(vector4);
        TUT_CHECK_MSG((vec3 == vec3a), "5:setVec:Fail to initialize ");
    }

    TUT_CASE("v3math_test::v3math_object_test_7")
    {
        using namespace tut;
        F32 x = 2.32f, y = 3.212f, z = -.12f;
        F32 min = 0.0001f, max = 3.0f;
        LLVector3 vec3(x,y,z);
        TUT_CHECK_MSG(true == vec3.clamp(min, max) && x == vec3.mV[VX] && max == vec3.mV[VY] && min == vec3.mV[VZ], "1:clamp:Fail  ");
        x = 1.f, y = 2.2f, z = 2.8f;
        vec3.setVec(x,y,z);
        TUT_CHECK_MSG(false == vec3.clamp(min, max), "2:clamp:Fail  ");
    }

    TUT_CASE("v3math_test::v3math_object_test_8")
    {
        using namespace tut;
        F32 x = 2.32f, y = 1.212f, z = -.12f;
        LLVector3 vec3(x,y,z);
        TUT_CHECK_MSG(is_approx_equal(vec3.magVecSquared(), (x*x + y*y + z*z)), "1:magVecSquared:Fail ");
        TUT_CHECK_MSG(is_approx_equal(vec3.magVec(), (F32) sqrt(x*x + y*y + z*z)), "2:magVec:Fail ");
    }

    TUT_CASE("v3math_test::v3math_object_test_9")
    {
        using namespace tut;
        F32 x =-2.0f, y = -3.0f, z = 1.23f ;
        LLVector3 vec3(x,y,z);
        TUT_CHECK_MSG((true == vec3.abs()), "1:abs():Fail ");
        TUT_CHECK_MSG((false == vec3.isNull()), "2:isNull():Fail");    //Returns true if vector has a _very_small_ length
        x =.00000001f, y = .000001001f, z = .000001001f;
        vec3.setVec(x,y,z);
        TUT_CHECK_MSG((true == vec3.isNull()), "3:isNull(): Fail ");
    }

    TUT_CASE("v3math_test::v3math_object_test_10")
    {
        using namespace tut;
        F32 x =-2.0f, y = -3.0f, z = 1.f ;
        LLVector3 vec3(x,y,z),vec3a;
        TUT_CHECK_MSG((true == vec3a.isExactlyZero()), "1:isExactlyZero():Fail ");
        vec3a = vec3a.scaleVec(vec3);
        TUT_CHECK_MSG(vec3a.mV[VX] == 0.f && vec3a.mV[VY] == 0.f && vec3a.mV[VZ] == 0.f, "2:scaleVec: Fail ");
        vec3a.setVec(x,y,z);
        vec3a = vec3a.scaleVec(vec3);
        TUT_CHECK_MSG(((4 == vec3a.mV[VX]) && (9 == vec3a.mV[VY]) &&(1 == vec3a.mV[VZ])), "3:scaleVec: Fail ");
        TUT_CHECK_MSG((false == vec3.isExactlyZero()), "4:isExactlyZero():Fail ");
    }

    TUT_CASE("v3math_test::v3math_object_test_11")
    {
        using namespace tut;
        F32 x =20.0f, y = 30.0f, z = 15.f ;
        F32 angle = 100.f;
        LLVector3 vec3(x,y,z),vec3a(1.f,2.f,3.f);
        vec3a = vec3a.rotVec(angle, vec3);
        LLVector3 vec3b(1.f,2.f,3.f);
        vec3b = vec3b.rotVec(angle, vec3);
        TUT_ENSURE_EQ("rotVec():Fail", vec3b, vec3a);
    }

    TUT_CASE("v3math_test::v3math_object_test_12")
    {
        using namespace tut;
        F32 x =-2.0f, y = -3.0f, z = 1.f ;
        LLVector3 vec3(x,y,z);
        TUT_CHECK_MSG(( x ==  vec3[0]), "1:operator [] failed");
        TUT_CHECK_MSG(( y ==  vec3[1]), "2:operator [] failed");
        TUT_CHECK_MSG(( z ==  vec3[2]), "3:operator [] failed");

        vec3.clearVec();
        x = 23.f, y = -.2361f, z = 3.25;
        vec3.setVec(x,y,z);
        F32 &ref1 = vec3[0];
        TUT_CHECK_MSG(( ref1 ==  vec3[0]), "4:operator [] failed");
        F32 &ref2 = vec3[1];
        TUT_CHECK_MSG(( ref2 ==  vec3[1]), "5:operator [] failed");
        F32 &ref3 = vec3[2];
        TUT_CHECK_MSG(( ref3 ==  vec3[2]), "6:operator [] failed");
    }

    TUT_CASE("v3math_test::v3math_object_test_13")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f,z1 = 1.2f, x2 = -2.3f, y2 = 1.11f, z2 = 1234.234f;
        F32 val1, val2, val3;
        LLVector3 vec3(x1,y1,z1), vec3a(x2,y2,z2), vec3b;
        vec3b = vec3 + vec3a ;
        val1 = x1+x2;
        val2 = y1+y2;
        val3 = z1+z2;
        TUT_CHECK_MSG((val1 == vec3b.mV[VX]) && (val2 == vec3b.mV[VY]) && (val3 == vec3b.mV[VZ]), "1:operator+ failed");

        vec3.clearVec();
        vec3a.clearVec();
        vec3b.clearVec();
        x1 = -.235f, y1 = -24.32f,z1 = 2.13f,  x2 = -2.3f, y2 = 1.f, z2 = 34.21f;
        vec3.setVec(x1,y1,z1);
        vec3a.setVec(x2,y2,z2);
        vec3b = vec3 + vec3a;
        val1 = x1+x2;
        val2 = y1+y2;
        val3 = z1+z2;
        TUT_CHECK_MSG((val1 == vec3b.mV[VX]) && (val2 == vec3b.mV[VY]) && (val3 == vec3b.mV[VZ]), "2:operator+ failed");
    }

    TUT_CASE("v3math_test::v3math_object_test_14")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f,z1 = 1.2f, x2 = -2.3f, y2 = 1.11f, z2 = 1234.234f;
        F32 val1, val2, val3;
        LLVector3 vec3(x1,y1,z1), vec3a(x2,y2,z2), vec3b;
        vec3b = vec3 - vec3a ;
        val1 = x1-x2;
        val2 = y1-y2;
        val3 = z1-z2;
        TUT_CHECK_MSG((val1 == vec3b.mV[VX]) && (val2 == vec3b.mV[VY]) && (val3 == vec3b.mV[VZ]), "1:operator- failed");

        vec3.clearVec();
        vec3a.clearVec();
        vec3b.clearVec();
        x1 = -.235f, y1 = -24.32f,z1 = 2.13f,  x2 = -2.3f, y2 = 1.f, z2 = 34.21f;
        vec3.setVec(x1,y1,z1);
        vec3a.setVec(x2,y2,z2);
        vec3b = vec3 - vec3a;
        val1 = x1-x2;
        val2 = y1-y2;
        val3 = z1-z2;
        TUT_CHECK_MSG((val1 == vec3b.mV[VX]) && (val2 == vec3b.mV[VY]) && (val3 == vec3b.mV[VZ]), "2:operator- failed");
    }

    TUT_CASE("v3math_test::v3math_object_test_15")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f,z1 = 1.2f, x2 = -2.3f, y2 = 1.11f, z2 = 1234.234f;
        F32 val1, val2, val3;
        LLVector3 vec3(x1,y1,z1), vec3a(x2,y2,z2);
        val1 = vec3 * vec3a;
        val2 = x1*x2 + y1*y2 + z1*z2;
        TUT_ENSURE_EQ("1:operator* failed", val1, val2);

        vec3a.clearVec();
        F32 mulVal = 4.332f;
        vec3a = vec3 * mulVal;
        val1 = x1*mulVal;
        val2 = y1*mulVal;
        val3 = z1*mulVal;
        TUT_CHECK_MSG((val1 == vec3a.mV[VX]) && (val2 == vec3a.mV[VY])&& (val3 == vec3a.mV[VZ]), "2:operator* failed");
        vec3a.clearVec();
        vec3a = mulVal * vec3;
        TUT_CHECK_MSG((val1 == vec3a.mV[VX]) && (val2 == vec3a.mV[VY])&& (val3 == vec3a.mV[VZ]), "3:operator* failed ");
    }

    TUT_CASE("v3math_test::v3math_object_test_16")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f,z1 = 1.2f, x2 = -2.3f, y2 = 1.11f, z2 = 1234.234f;
        F32 val1, val2, val3;
        LLVector3 vec3(x1,y1,z1), vec3a(x2,y2,z2), vec3b;
        vec3b = vec3 % vec3a ;
        val1 = y1*z2 - y2*z1;
        val2 = z1*x2 -z2*x1;
        val3 = x1*y2-x2*y1;
        TUT_CHECK_MSG((val1 == vec3b.mV[VX]) && (val2 == vec3b.mV[VY]) && (val3 == vec3b.mV[VZ]), "1:operator% failed");

        vec3.clearVec();
        vec3a.clearVec();
        vec3b.clearVec();
        x1 =112.f, y1 = 22.3f,z1 = 1.2f, x2 = -2.3f, y2 = 341.11f, z2 = 1234.234f;
        vec3.setVec(x1,y1,z1);
        vec3a.setVec(x2,y2,z2);
        vec3b = vec3 % vec3a ;
        val1 = y1*z2 - y2*z1;
        val2 = z1*x2 -z2*x1;
        val3 = x1*y2-x2*y1;
        TUT_CHECK_MSG((val1 == vec3b.mV[VX]) && (val2 == vec3b.mV[VY]) && (val3 == vec3b.mV[VZ]), "2:operator% failed ");
    }

    TUT_CASE("v3math_test::v3math_object_test_17")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f,z1 = 1.2f, div = 3.2f;
        F32 t = 1.f / div, val1, val2, val3;
        LLVector3 vec3(x1,y1,z1), vec3a;
        vec3a = vec3 / div;
        val1 = x1 * t;
        val2 = y1 * t;
        val3 = z1 *t;
        TUT_CHECK_MSG((val1 == vec3a.mV[VX]) && (val2 == vec3a.mV[VY]) && (val3 == vec3a.mV[VZ]), "1:operator/ failed");

        vec3a.clearVec();
        x1 = -.235f, y1 = -24.32f, z1 = .342f, div = -2.2f;
        t = 1.f / div;
        vec3.setVec(x1,y1,z1);
        vec3a = vec3 / div;
        val1 = x1 * t;
        val2 = y1 * t;
        val3 = z1 *t;
        TUT_CHECK_MSG((val1 == vec3a.mV[VX]) && (val2 == vec3a.mV[VY]) && (val3 == vec3a.mV[VZ]), "2:operator/ failed");
    }

    TUT_CASE("v3math_test::v3math_object_test_18")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f,z1 = 1.2f;
        LLVector3 vec3(x1,y1,z1), vec3a(x1,y1,z1);
        TUT_CHECK_MSG((vec3 == vec3a), "1:operator== failed");

        vec3a.clearVec();
        x1 = -.235f, y1 = -24.32f, z1 = .342f;
        vec3.clearVec();
        vec3a.clearVec();
        vec3.setVec(x1,y1,z1);
        vec3a.setVec(x1,y1,z1);
        TUT_CHECK_MSG((vec3 == vec3a), "2:operator== failed ");
    }

    TUT_CASE("v3math_test::v3math_object_test_19")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f,z1 = 1.2f, x2 =112.f, y2 = 2.234f,z2 = 11.2f;;
        LLVector3 vec3(x1,y1,z1), vec3a(x2,y2,z2);
        TUT_CHECK_MSG((vec3a != vec3), "1:operator!= failed");

        vec3.clearVec();
        vec3.clearVec();
        vec3a.setVec(vec3);
        TUT_CHECK_MSG(( false == (vec3a != vec3)), "2:operator!= failed");
    }

    TUT_CASE("v3math_test::v3math_object_test_20")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f,z1 = 1.2f, x2 =112.f, y2 = 2.2f,z2 = 11.2f;;
        LLVector3 vec3(x1,y1,z1), vec3a(x2,y2,z2);
        vec3a += vec3;
        F32 val1, val2, val3;
        val1 = x1+x2;
        val2 = y1+y2;
        val3 = z1+z2;
        TUT_CHECK_MSG((val1 == vec3a.mV[VX]) && (val2 == vec3a.mV[VY])&& (val3 == vec3a.mV[VZ]), "1:operator+= failed");
    }

    TUT_CASE("v3math_test::v3math_object_test_21")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f,z1 = 1.2f, x2 =112.f, y2 = 2.2f,z2 = 11.2f;;
        LLVector3 vec3(x1,y1,z1), vec3a(x2,y2,z2);
        vec3a -= vec3;
        F32 val1, val2, val3;
        val1 = x2-x1;
        val2 = y2-y1;
        val3 = z2-z1;
        TUT_CHECK_MSG((val1 == vec3a.mV[VX]) && (val2 == vec3a.mV[VY])&& (val3 == vec3a.mV[VZ]), "1:operator-= failed");
    }

    TUT_CASE("v3math_test::v3math_object_test_22")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f,z1 = 1.2f, x2 = -2.3f, y2 = 1.11f, z2 = 1234.234f;
        F32 val1,val2,val3;
        LLVector3 vec3(x1,y1,z1), vec3a(x2,y2,z2);
        vec3a *= vec3;
        val1 = x1*x2;
        val2 = y1*y2;
        val3 = z1*z2;
        TUT_CHECK_MSG((val1 == vec3a.mV[VX]) && (val2 == vec3a.mV[VY])&& (val3 == vec3a.mV[VZ]), "1:operator*= failed");

        F32 mulVal = 4.332f;
        vec3 *=mulVal;
        val1 = x1*mulVal;
        val2 = y1*mulVal;
        val3 = z1*mulVal;
        TUT_CHECK_MSG(is_approx_equal(val1, vec3.mV[VX]) && is_approx_equal(val2, vec3.mV[VY]) && is_approx_equal(val3, vec3.mV[VZ]), "2:operator*= failed ");
    }

    TUT_CASE("v3math_test::v3math_object_test_23")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f,z1 = 1.2f, x2 = -2.3f, y2 = 1.11f, z2 = 1234.234f;
        LLVector3 vec3(x1,y1,z1), vec3a(x2,y2,z2),vec3b;
        vec3b = vec3a % vec3;
        vec3a %= vec3;
        TUT_ENSURE_EQ("1:operator%= failed", vec3a, vec3b);
    }

    TUT_CASE("v3math_test::v3math_object_test_24")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f,z1 = 1.2f, div = 3.2f;
        F32 t = 1.f / div, val1, val2, val3;
        LLVector3 vec3a(x1,y1,z1);
        vec3a /= div;
        val1 = x1 * t;
        val2 = y1 * t;
        val3 = z1 *t;
        TUT_CHECK_MSG((val1 == vec3a.mV[VX]) && (val2 == vec3a.mV[VY]) && (val3 == vec3a.mV[VZ]), "1:operator/= failed");
    }

    TUT_CASE("v3math_test::v3math_object_test_25")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f,z1 = 1.2f;
        LLVector3 vec3(x1,y1,z1), vec3a;
        vec3a = -vec3;
        TUT_CHECK_MSG((-vec3a == vec3), "1:operator- failed");
    }

    TUT_CASE("v3math_test::v3math_object_test_26")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f,z1 = 1.2f;
        std::ostringstream stream1, stream2;
        LLVector3 vec3(x1,y1,z1), vec3a;
        stream1 << vec3;
        vec3a.setVec(x1,y1,z1);
        stream2 << vec3a;
        TUT_CHECK_MSG((stream1.str() == stream2.str()), "1:operator << failed");
    }

    TUT_CASE("v3math_test::v3math_object_test_27")
    {
        using namespace tut;
        F32 x1 =-2.3f, y1 = 2.f,z1 = 1.2f, x2 = 1.3f, y2 = 1.11f, z2 = 1234.234f;
        LLVector3 vec3(x1,y1,z1), vec3a(x2,y2,z2);
        TUT_CHECK_MSG((true == (vec3 < vec3a)), "1:operator< failed");
        x1 =-2.3f, y1 = 2.f,z1 = 1.2f, x2 = 1.3f, y2 = 2.f, z2 = 1234.234f;
        vec3.setVec(x1,y1,z1);
        vec3a.setVec(x2,y2,z2);
        TUT_CHECK_MSG((true == (vec3 < vec3a)), "2:operator< failed ");
        x1 =2.3f, y1 = 2.f,z1 = 1.2f, x2 = 1.3f,
        vec3.setVec(x1,y1,z1);
        vec3a.setVec(x2,y2,z2);
        TUT_CHECK_MSG((false == (vec3 < vec3a)), "3:operator< failed ");
    }

    TUT_CASE("v3math_test::v3math_object_test_28")
    {
        using namespace tut;
        F32 x1 =1.23f, y1 = 2.f,z1 = 4.f;
        std::string buf("1.23 2. 4");
        LLVector3 vec3, vec3a(x1,y1,z1);
        LLVector3::parseVector3(buf, &vec3);
        TUT_ENSURE_EQ("1:parseVector3 failed", vec3, vec3a);
    }

    TUT_CASE("v3math_test::v3math_object_test_29")
    {
        using namespace tut;
        F32 x1 =1.f, y1 = 2.f,z1 = 4.f;
        LLVector3 vec3(x1,y1,z1),vec3a,vec3b;
        vec3a.setVec(1,1,1);
        vec3a.scaleVec(vec3);
        TUT_ENSURE_EQ("1:scaleVec failed", vec3, vec3a);
        vec3a.clearVec();
        vec3a.setVec(x1,y1,z1);
        vec3a.scaleVec(vec3);
        TUT_CHECK_MSG(((1.f ==vec3a.mV[VX])&& (4.f ==vec3a.mV[VY]) && (16.f ==vec3a.mV[VZ])), "2:scaleVec failed");
    }

    TUT_CASE("v3math_test::v3math_object_test_30")
    {
        using namespace tut;
        F32 x1 =-2.3f, y1 = 2.f,z1 = 1.2f, x2 = 1.3f, y2 = 1.11f, z2 = 1234.234f;
        F32 val = 2.3f,val1,val2,val3;
        val1 = x1 + (x2 - x1)* val;
        val2 = y1 + (y2 - y1)* val;
        val3 = z1 + (z2 - z1)* val;
        LLVector3 vec3(x1,y1,z1),vec3a(x2,y2,z2);
        LLVector3 vec3b = lerp(vec3,vec3a,val);
        TUT_CHECK_MSG(((val1 ==vec3b.mV[VX])&& (val2 ==vec3b.mV[VY]) && (val3 ==vec3b.mV[VZ])), "1:lerp failed");
    }

    TUT_CASE("v3math_test::v3math_object_test_31")
    {
        using namespace tut;
        F32 x1 =-2.3f, y1 = 2.f,z1 = 1.2f, x2 = 1.3f, y2 = 1.f, z2 = 1.f;
        F32 val1,val2;
        LLVector3 vec3(x1,y1,z1),vec3a(x2,y2,z2);
        val1 = dist_vec(vec3,vec3a);
        val2 = (F32) sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)* (y1 - y2) + (z1 - z2)* (z1 -z2));
        TUT_ENSURE_EQ("1:dist_vec: Fail ", val2, val1);
        val1 = dist_vec_squared(vec3,vec3a);
        val2 =((x1 - x2)*(x1 - x2) + (y1 - y2)* (y1 - y2) + (z1 - z2)* (z1 -z2));
        TUT_ENSURE_EQ("2:dist_vec_squared: Fail ", val2, val1);
        val1 = dist_vec_squared2D(vec3, vec3a);
        val2 =(x1 - x2)*(x1 - x2) + (y1 - y2)* (y1 - y2);
        TUT_ENSURE_EQ("3:dist_vec_squared2D: Fail ", val2, val1);
    }

    TUT_CASE("v3math_test::v3math_object_test_32")
    {
        using namespace tut;
        F32 x =12.3524f, y = -342.f,z = 4.126341f;
        LLVector3 vec3(x,y,z);
        F32 mag = vec3.normVec();
        mag = 1.f/ mag;
        F32 val1 = x* mag, val2 = y* mag, val3 = z* mag;
        TUT_CHECK_MSG(is_approx_equal(val1, vec3.mV[VX]) && is_approx_equal(val2, vec3.mV[VY]) && is_approx_equal(val3, vec3.mV[VZ]), "1:normVec: Fail ");
        x = 0.000000001f, y = 0.f, z = 0.f;
        vec3.clearVec();
        vec3.setVec(x,y,z);
        mag = vec3.normVec();
        val1 = x* mag, val2 = y* mag, val3 = z* mag;
        TUT_CHECK_MSG((mag == 0.) && (0. == vec3.mV[VX]) && (0. == vec3.mV[VY])&& (0. == vec3.mV[VZ]), "2:normVec: Fail ");
    }

    TUT_CASE("v3math_test::v3math_object_test_33")
    {
        using namespace tut;
        F32 x = -202.23412f, y = 123.2312f, z = -89.f;
        LLVector3 vec(x,y,z);
        vec.snap(2);
        TUT_CHECK_MSG(is_approx_equal(-202.23f, vec.mV[VX]) && is_approx_equal(123.23f, vec.mV[VY]) && is_approx_equal(-89.f, vec.mV[VZ]), "1:snap: Fail ");
    }

    TUT_CASE("v3math_test::v3math_object_test_34")
    {
        using namespace tut;
        F32 x = 10.f, y = 20.f, z = -15.f;
        F32 x1, y1, z1;
        F32 lowerxy = 0.f, upperxy = 1.0f, lowerz = -1.0f, upperz = 1.f;
        LLVector3 vec3(x,y,z);
        vec3.quantize16(lowerxy,upperxy,lowerz,upperz);
        x1 = U16_to_F32(F32_to_U16(x, lowerxy, upperxy), lowerxy, upperxy);
        y1 = U16_to_F32(F32_to_U16(y, lowerxy, upperxy), lowerxy, upperxy);
        z1 = U16_to_F32(F32_to_U16(z, lowerz,  upperz),  lowerz,  upperz);
        TUT_CHECK_MSG(is_approx_equal(x1, vec3.mV[VX]) && is_approx_equal(y1, vec3.mV[VY]) && is_approx_equal(z1, vec3.mV[VZ]), "1:quantize16: Fail ");
        LLVector3 vec3a(x,y,z);
        vec3a.quantize8(lowerxy,upperxy,lowerz,upperz);
        x1 = U8_to_F32(F32_to_U8(x, lowerxy, upperxy), lowerxy, upperxy);
        y1 = U8_to_F32(F32_to_U8(y, lowerxy, upperxy), lowerxy, upperxy);
        z1 = U8_to_F32(F32_to_U8(z, lowerz, upperz), lowerz, upperz);
        TUT_CHECK_MSG(is_approx_equal(x1, vec3a.mV[VX]) && is_approx_equal(y1, vec3a.mV[VY]) && is_approx_equal(z1, vec3a.mV[VZ]), "2:quantize8: Fail ");
    }

    TUT_CASE("v3math_test::v3math_object_test_35")
    {
        using namespace tut;
        LLSD sd = LLSD::emptyArray();
        sd[0] = 1.f;

        LLVector3 parsed_1(sd);
        TUT_CHECK_MSG(is_approx_equal(parsed_1.mV[VX], 1.f) && is_approx_equal(parsed_1.mV[VY], 0.f) && is_approx_equal(parsed_1.mV[VZ], 0.f), "1:LLSD parse: Fail ");

        sd[1] = 2.f;
        LLVector3 parsed_2(sd);
        TUT_CHECK_MSG(is_approx_equal(parsed_2.mV[VX], 1.f) && is_approx_equal(parsed_2.mV[VY], 2.f) && is_approx_equal(parsed_2.mV[VZ], 0.f), "2:LLSD parse: Fail ");

        sd[2] = 3.f;
        LLVector3 parsed_3(sd);
        TUT_CHECK_MSG(is_approx_equal(parsed_3.mV[VX], 1.f) && is_approx_equal(parsed_3.mV[VY], 2.f) && is_approx_equal(parsed_3.mV[VZ], 3.f), "3:LLSD parse: Fail ");
    }
}
